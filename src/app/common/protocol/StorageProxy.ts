// **********************************************************************
// Parsed By TarsParser(3.0.12), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "Storage.tars" by Client Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";
import * as TarsRpc from "@tars/rpc";

const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo<Ret, Arg>(data: SharedFunctionInfo<Ret, Arg>) { return data; }
function _makeError(data: TarsRpc.RpcResponse, message: string, type?: number): TarsRpc.RpcError {
    var error: any = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    } else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}

export interface SharedFunctionInfo<Ret = any, Arg = any> extends TarsRpc.SharedFunctionInfo {
    tarsEncoder (...args: any[]): TarsStream.BinBuffer,
    tarsDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    tupEncoder (...args: any[]): TarsStream.UniAttribute,
    tupDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    errorResponser (data: TarsRpc.RpcResponse): never
}

export namespace Base {
    export enum STORAGE_RT {
        S_OK = 0,
        S_NO_DATA = -1,
        S_ERROR = -2,
        S_VERSION = -3,
        S_TIMESTAMP = -4,
        S_TABLE_NAME = -5,
        S_TABLE_EXIST = -6,
        S_TABLE_NOT_EXIST = -7,
        S_JSON_FIELD_NOT_EXITS = -8,
        S_JSON_OPERATOR_NOT_SUPPORT = -9,
        S_JSON_FIELD_TYPE_ERROR = -10,
        S_JSON_VALUE_TYPE_ERROR = -11,
        S_JSON_VALUE_NOT_JSON = -12,
        S_QUEUE_NAME = -13,
        S_QUEUE_EXIST = -14,
        S_QUEUE_NOT_EXIST = -15
    }

    export namespace STORAGE_RT {
        export const _classname = "Base.STORAGE_RT";
        export function _write(os: TarsStream.TarsOutputStream, tag: number, val: number) { return os.writeInt32(tag, val); }
        export function _read(is: TarsStream.TarsInputStream, tag: number, def?: number) { return is.readInt32(tag, true, def); }
    }

    export enum StorageOperator {
        SO_REPLACE = 0,
        SO_ADD = 1,
        SO_SUB = 2,
        SO_REVERSE = 3,
        SO_ADD_NO_REPEAT = 4
    }

    export namespace StorageOperator {
        export const _classname = "Base.StorageOperator";
        export function _write(os: TarsStream.TarsOutputStream, tag: number, val: number) { return os.writeInt32(tag, val); }
        export function _read(is: TarsStream.TarsInputStream, tag: number, def?: number) { return is.readInt32(tag, true, def); }
    }

    export enum FieldType {
        FT_INTEGER = 1,
        FT_DOUBLE = 2,
        FT_BOOLEAN = 3,
        FT_STRING = 4,
        FT_ARRAY = 5
    }

    export namespace FieldType {
        export const _classname = "Base.FieldType";
        export function _write(os: TarsStream.TarsOutputStream, tag: number, val: number) { return os.writeInt32(tag, val); }
        export function _read(is: TarsStream.TarsInputStream, tag: number, def?: number) { return is.readInt32(tag, true, def); }
    }


    export class Options {
        leader: boolean = false;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.Options";
        protected static _classname = "Base.Options";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new Options;
            tmp.leader = is.readBoolean(0, false, false);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeBoolean(0, this.leader);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): Options.Object { 
            return {
                leader: this.leader
            };
        }

        readFromObject(json: Options.Object) { 
            _hasOwnProperty.call(json, "leader") && (this.leader = json.leader!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new Options();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.Options._readFrom(is);
        }
    }

    export namespace Options {
        export interface Object {
            leader?: boolean;
        }
    }

    export class StorageKey {
        table: string = "";
        mkey: string = "";
        ukey: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "Base.StorageKey";
        protected static _classname = "Base.StorageKey";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new StorageKey;
            tmp.table = is.readString(0, false, "");
            tmp.mkey = is.readString(1, false, "");
            tmp.ukey = is.readString(2, false, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.table);
            os.writeString(1, this.mkey);
            os.writeString(2, this.ukey);
        }

        protected _equal(anItem: any): boolean {
            return this.table === anItem.table && 
                        this.mkey === anItem.mkey && 
                        this.ukey === anItem.ukey;
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): StorageKey.Object { 
            return {
                table: this.table,
                mkey: this.mkey,
                ukey: this.ukey
            };
        }

        readFromObject(json: StorageKey.Object) { 
            _hasOwnProperty.call(json, "table") && (this.table = json.table!);
            _hasOwnProperty.call(json, "mkey") && (this.mkey = json.mkey!);
            _hasOwnProperty.call(json, "ukey") && (this.ukey = json.ukey!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new StorageKey();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.StorageKey._readFrom(is);
        }
    }

    export namespace StorageKey {
        export interface Object {
            table?: string;
            mkey?: string;
            ukey?: string;
        }
    }

    export class StorageValue {
        expireTime: number = 0;
        version: number = 0;
        timestamp: number = 0;
        data: TarsStream.BinBuffer = new TarsStream.BinBuffer;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.StorageValue";
        protected static _classname = "Base.StorageValue";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new StorageValue;
            tmp.expireTime = is.readInt64(0, false, 0);
            tmp.version = is.readInt32(1, false, 0);
            tmp.timestamp = is.readInt64(2, false, 0);
            tmp.data = is.readBytes(3, false, TarsStream.BinBuffer);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.expireTime);
            os.writeInt32(1, this.version);
            os.writeInt64(2, this.timestamp);
            os.writeBytes(3, this.data);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): StorageValue.Object { 
            return {
                expireTime: this.expireTime,
                version: this.version,
                timestamp: this.timestamp,
                data: this.data.toObject()
            };
        }

        readFromObject(json: StorageValue.Object) { 
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime!);
            _hasOwnProperty.call(json, "version") && (this.version = json.version!);
            _hasOwnProperty.call(json, "timestamp") && (this.timestamp = json.timestamp!);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new StorageValue();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.StorageValue._readFrom(is);
        }
    }

    export namespace StorageValue {
        export interface Object {
            expireTime?: number;
            version?: number;
            timestamp?: number;
            data?: Buffer;
        }
    }

    export class StorageData {
        skey: Base.StorageKey = new Base.StorageKey;
        svalue: Base.StorageValue = new Base.StorageValue;
        ret: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.StorageData";
        protected static _classname = "Base.StorageData";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new StorageData;
            tmp.skey = is.readStruct(0, false, Base.StorageKey);
            tmp.svalue = is.readStruct(1, false, Base.StorageValue);
            tmp.ret = is.readInt32(2, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeStruct(0, this.skey);
            os.writeStruct(1, this.svalue);
            os.writeInt32(2, this.ret);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): StorageData.Object { 
            return {
                skey: this.skey.toObject(),
                svalue: this.svalue.toObject(),
                ret: this.ret
            };
        }

        readFromObject(json: StorageData.Object) { 
            _hasOwnProperty.call(json, "skey") && (this.skey.readFromObject(json.skey!));
            _hasOwnProperty.call(json, "svalue") && (this.svalue.readFromObject(json.svalue!));
            _hasOwnProperty.call(json, "ret") && (this.ret = json.ret!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new StorageData();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.StorageData._readFrom(is);
        }
    }

    export namespace StorageData {
        export interface Object {
            skey?: Base.StorageKey.Object;
            svalue?: Base.StorageValue.Object;
            ret?: number;
        }
    }

    export class StorageUpdate {
        field: string = "";
        op: Base.StorageOperator = Base.StorageOperator.SO_REPLACE;
        value: string = "";
        type: Base.FieldType = Base.FieldType.FT_INTEGER;
        def: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "Base.StorageUpdate";
        protected static _classname = "Base.StorageUpdate";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new StorageUpdate;
            tmp.field = is.readString(0, true, "");
            tmp.op = is.readInt32(1, true, Base.StorageOperator.SO_REPLACE);
            tmp.value = is.readString(2, false, "");
            tmp.type = is.readInt32(3, false, Base.FieldType.FT_INTEGER);
            tmp.def = is.readString(4, false, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.field);
            os.writeInt32(1, this.op);
            os.writeString(2, this.value);
            os.writeInt32(3, this.type);
            os.writeString(4, this.def);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): StorageUpdate.Object { 
            return {
                field: this.field,
                op: this.op,
                value: this.value,
                type: this.type,
                def: this.def
            };
        }

        readFromObject(json: StorageUpdate.Object) { 
            _hasOwnProperty.call(json, "field") && (this.field = json.field);
            _hasOwnProperty.call(json, "op") && (this.op = json.op);
            _hasOwnProperty.call(json, "value") && (this.value = json.value!);
            _hasOwnProperty.call(json, "type") && (this.type = json.type!);
            _hasOwnProperty.call(json, "def") && (this.def = json.def!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new StorageUpdate();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.StorageUpdate._readFrom(is);
        }
    }

    export namespace StorageUpdate {
        export interface Object {
            field: string;
            op: Base.StorageOperator;
            value?: string;
            type?: Base.FieldType;
            def?: string;
        }
    }

    export class StorageJson {
        skey: Base.StorageKey = new Base.StorageKey;
        supdate: TarsStream.List<Base.StorageUpdate> = new TarsStream.List(Base.StorageUpdate);

        protected _proto_struct_name_ = "";
        protected _classname = "Base.StorageJson";
        protected static _classname = "Base.StorageJson";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new StorageJson;
            tmp.skey = is.readStruct(0, false, Base.StorageKey);
            tmp.supdate = is.readList(1, false, TarsStream.List(Base.StorageUpdate));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeStruct(0, this.skey);
            os.writeList(1, this.supdate);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): StorageJson.Object { 
            return {
                skey: this.skey.toObject(),
                supdate: this.supdate.toObject()
            };
        }

        readFromObject(json: StorageJson.Object) { 
            _hasOwnProperty.call(json, "skey") && (this.skey.readFromObject(json.skey!));
            _hasOwnProperty.call(json, "supdate") && (this.supdate.readFromObject(json.supdate!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new StorageJson();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.StorageJson._readFrom(is);
        }
    }

    export namespace StorageJson {
        export interface Object {
            skey?: Base.StorageKey.Object;
            supdate?: Array<Base.StorageUpdate.Object>;
        }
    }

    export class PageReq {
        skey: Base.StorageKey = new Base.StorageKey;
        limit: number = 10;
        forward: boolean = true;
        include: boolean = true;
        over: boolean = false;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.PageReq";
        protected static _classname = "Base.PageReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PageReq;
            tmp.skey = is.readStruct(0, false, Base.StorageKey);
            tmp.limit = is.readInt32(1, false, 10);
            tmp.forward = is.readBoolean(2, false, true);
            tmp.include = is.readBoolean(3, false, true);
            tmp.over = is.readBoolean(4, false, false);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeStruct(0, this.skey);
            os.writeInt32(1, this.limit);
            os.writeBoolean(2, this.forward);
            os.writeBoolean(3, this.include);
            os.writeBoolean(4, this.over);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PageReq.Object { 
            return {
                skey: this.skey.toObject(),
                limit: this.limit,
                forward: this.forward,
                include: this.include,
                over: this.over
            };
        }

        readFromObject(json: PageReq.Object) { 
            _hasOwnProperty.call(json, "skey") && (this.skey.readFromObject(json.skey!));
            _hasOwnProperty.call(json, "limit") && (this.limit = json.limit!);
            _hasOwnProperty.call(json, "forward") && (this.forward = json.forward!);
            _hasOwnProperty.call(json, "include") && (this.include = json.include!);
            _hasOwnProperty.call(json, "over") && (this.over = json.over!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PageReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.PageReq._readFrom(is);
        }
    }

    export namespace PageReq {
        export interface Object {
            skey?: Base.StorageKey.Object;
            limit?: number;
            forward?: boolean;
            include?: boolean;
            over?: boolean;
        }
    }

    export class QueueData {
        expireTime: number = 0;
        data: TarsStream.BinBuffer = new TarsStream.BinBuffer;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.QueueData";
        protected static _classname = "Base.QueueData";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueueData;
            tmp.expireTime = is.readInt64(0, false, 0);
            tmp.data = is.readBytes(5, false, TarsStream.BinBuffer);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt64(0, this.expireTime);
            os.writeBytes(5, this.data);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueueData.Object { 
            return {
                expireTime: this.expireTime,
                data: this.data.toObject()
            };
        }

        readFromObject(json: QueueData.Object) { 
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime!);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueueData();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.QueueData._readFrom(is);
        }
    }

    export namespace QueueData {
        export interface Object {
            expireTime?: number;
            data?: Buffer;
        }
    }

    export class QueuePushReq {
        queue: string = "";
        back: boolean = true;
        expireTime: number = 0;
        data: TarsStream.BinBuffer = new TarsStream.BinBuffer;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.QueuePushReq";
        protected static _classname = "Base.QueuePushReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueuePushReq;
            tmp.queue = is.readString(0, false, "");
            tmp.back = is.readBoolean(1, false, true);
            tmp.expireTime = is.readInt64(2, false, 0);
            tmp.data = is.readBytes(5, false, TarsStream.BinBuffer);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.queue);
            os.writeBoolean(1, this.back);
            os.writeInt64(2, this.expireTime);
            os.writeBytes(5, this.data);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueuePushReq.Object { 
            return {
                queue: this.queue,
                back: this.back,
                expireTime: this.expireTime,
                data: this.data.toObject()
            };
        }

        readFromObject(json: QueuePushReq.Object) { 
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue!);
            _hasOwnProperty.call(json, "back") && (this.back = json.back!);
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime!);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueuePushReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.QueuePushReq._readFrom(is);
        }
    }

    export namespace QueuePushReq {
        export interface Object {
            queue?: string;
            back?: boolean;
            expireTime?: number;
            data?: Buffer;
        }
    }

    export class QueuePopReq {
        queue: string = "";
        back: boolean = true;
        count: number = 1;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.QueuePopReq";
        protected static _classname = "Base.QueuePopReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueuePopReq;
            tmp.queue = is.readString(0, false, "");
            tmp.back = is.readBoolean(1, false, true);
            tmp.count = is.readInt32(2, false, 1);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.queue);
            os.writeBoolean(1, this.back);
            os.writeInt32(2, this.count);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueuePopReq.Object { 
            return {
                queue: this.queue,
                back: this.back,
                count: this.count
            };
        }

        readFromObject(json: QueuePopReq.Object) { 
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue!);
            _hasOwnProperty.call(json, "back") && (this.back = json.back!);
            _hasOwnProperty.call(json, "count") && (this.count = json.count!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueuePopReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.QueuePopReq._readFrom(is);
        }
    }

    export namespace QueuePopReq {
        export interface Object {
            queue?: string;
            back?: boolean;
            count?: number;
        }
    }

    export class QueueRsp {
        queue: string = "";
        index: number = 0;
        expireTime: number = 0;
        data: TarsStream.BinBuffer = new TarsStream.BinBuffer;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.QueueRsp";
        protected static _classname = "Base.QueueRsp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueueRsp;
            tmp.queue = is.readString(0, false, "");
            tmp.index = is.readInt64(1, false, 0);
            tmp.expireTime = is.readInt64(2, false, 0);
            tmp.data = is.readBytes(3, false, TarsStream.BinBuffer);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.queue);
            os.writeInt64(1, this.index);
            os.writeInt64(2, this.expireTime);
            os.writeBytes(3, this.data);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueueRsp.Object { 
            return {
                queue: this.queue,
                index: this.index,
                expireTime: this.expireTime,
                data: this.data.toObject()
            };
        }

        readFromObject(json: QueueRsp.Object) { 
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue!);
            _hasOwnProperty.call(json, "index") && (this.index = json.index!);
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime!);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueueRsp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.QueueRsp._readFrom(is);
        }
    }

    export namespace QueueRsp {
        export interface Object {
            queue?: string;
            index?: number;
            expireTime?: number;
            data?: Buffer;
        }
    }

    export class QueueIndex {
        queue: string = "";
        index: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.QueueIndex";
        protected static _classname = "Base.QueueIndex";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueueIndex;
            tmp.queue = is.readString(0, false, "");
            tmp.index = is.readInt64(1, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.queue);
            os.writeInt64(1, this.index);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueueIndex.Object { 
            return {
                queue: this.queue,
                index: this.index
            };
        }

        readFromObject(json: QueueIndex.Object) { 
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue!);
            _hasOwnProperty.call(json, "index") && (this.index = json.index!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueueIndex();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.QueueIndex._readFrom(is);
        }
    }

    export namespace QueueIndex {
        export interface Object {
            queue?: string;
            index?: number;
        }
    }

    export class QueuePageReq {
        queue: string = "";
        index: string = "";
        limit: number = 10;
        forward: boolean = true;
        include: boolean = true;

        protected _proto_struct_name_ = "";
        protected _classname = "Base.QueuePageReq";
        protected static _classname = "Base.QueuePageReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new QueuePageReq;
            tmp.queue = is.readString(0, false, "");
            tmp.index = is.readString(1, false, "");
            tmp.limit = is.readInt32(2, false, 10);
            tmp.forward = is.readBoolean(3, false, true);
            tmp.include = is.readBoolean(4, false, true);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.queue);
            os.writeString(1, this.index);
            os.writeInt32(2, this.limit);
            os.writeBoolean(3, this.forward);
            os.writeBoolean(4, this.include);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): QueuePageReq.Object { 
            return {
                queue: this.queue,
                index: this.index,
                limit: this.limit,
                forward: this.forward,
                include: this.include
            };
        }

        readFromObject(json: QueuePageReq.Object) { 
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue!);
            _hasOwnProperty.call(json, "index") && (this.index = json.index!);
            _hasOwnProperty.call(json, "limit") && (this.limit = json.limit!);
            _hasOwnProperty.call(json, "forward") && (this.forward = json.forward!);
            _hasOwnProperty.call(json, "include") && (this.include = json.include!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new QueuePageReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.QueuePageReq._readFrom(is);
        }
    }

    export namespace QueuePageReq {
        export interface Object {
            queue?: string;
            index?: string;
            limit?: number;
            forward?: boolean;
            include?: boolean;
        }
    }

    export class BatchDataReq {
        sData: TarsStream.List<Base.StorageData> = new TarsStream.List(Base.StorageData);
        uData: TarsStream.List<Base.StorageJson> = new TarsStream.List(Base.StorageJson);
        qData: TarsStream.List<Base.QueuePushReq> = new TarsStream.List(Base.QueuePushReq);

        protected _proto_struct_name_ = "";
        protected _classname = "Base.BatchDataReq";
        protected static _classname = "Base.BatchDataReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new BatchDataReq;
            tmp.sData = is.readList(0, false, TarsStream.List(Base.StorageData));
            tmp.uData = is.readList(1, false, TarsStream.List(Base.StorageJson));
            tmp.qData = is.readList(2, false, TarsStream.List(Base.QueuePushReq));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeList(0, this.sData);
            os.writeList(1, this.uData);
            os.writeList(2, this.qData);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): BatchDataReq.Object { 
            return {
                sData: this.sData.toObject(),
                uData: this.uData.toObject(),
                qData: this.qData.toObject()
            };
        }

        readFromObject(json: BatchDataReq.Object) { 
            _hasOwnProperty.call(json, "sData") && (this.sData.readFromObject(json.sData!));
            _hasOwnProperty.call(json, "uData") && (this.uData.readFromObject(json.uData!));
            _hasOwnProperty.call(json, "qData") && (this.qData.readFromObject(json.qData!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new BatchDataReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.BatchDataReq._readFrom(is);
        }
    }

    export namespace BatchDataReq {
        export interface Object {
            sData?: Array<Base.StorageData.Object>;
            uData?: Array<Base.StorageJson.Object>;
            qData?: Array<Base.QueuePushReq.Object>;
        }
    }

    export class BatchDataRsp {
        sRsp: TarsStream.Map<Base.StorageKey, number> = new TarsStream.Map(Base.StorageKey, TarsStream.Int32);

        protected _proto_struct_name_ = "";
        protected _classname = "Base.BatchDataRsp";
        protected static _classname = "Base.BatchDataRsp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new BatchDataRsp;
            tmp.sRsp = is.readMap(0, false, TarsStream.Map(Base.StorageKey, TarsStream.Int32));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeMap(0, this.sRsp);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): BatchDataRsp.Object { 
            return {
                sRsp: this.sRsp.toObject()
            };
        }

        readFromObject(json: BatchDataRsp.Object) { 
            _hasOwnProperty.call(json, "sRsp") && (this.sRsp.readFromObject(json.sRsp!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new BatchDataRsp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.BatchDataRsp._readFrom(is);
        }
    }

    export namespace BatchDataRsp {
        export interface Object {
            sRsp?: never;
        }
    }

    export class StorageProxy {
        protected _name!: string
        protected _worker!: TarsRpc.ObjectProxy

        setTimeout (iTimeout: number) { this._worker.timeout = iTimeout; }
        getTimeout () { return this._worker.timeout; }
        setVersion (iVersion: number) { this._worker.version = iVersion; }
        getVersion () { return this._worker.version; }

        static createQueue = _castFunctionInfo({
            name: "createQueue",
            return: "int32",
            arguments: [{
                name: "queue",
                class: "string",
                direction: "in"
            }],
            tarsEncoder(queue: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, queue);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(queue: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("queue", queue);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::createQueue failed");
            }
        })

        createQueue(queue: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("createQueue", StorageProxy.createQueue.tupEncoder(queue, version), tars_options, StorageProxy.createQueue).then(StorageProxy.createQueue.tupDecoder, StorageProxy.createQueue.errorResponser);
            } else {
                return this._worker.tars_invoke("createQueue", StorageProxy.createQueue.tarsEncoder(queue), tars_options, StorageProxy.createQueue).then(StorageProxy.createQueue.tarsDecoder, StorageProxy.createQueue.errorResponser);
            }
        }

        static createTable = _castFunctionInfo({
            name: "createTable",
            return: "int32",
            arguments: [{
                name: "table",
                class: "string",
                direction: "in"
            }],
            tarsEncoder(table: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, table);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(table: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("table", table);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::createTable failed");
            }
        })

        createTable(table: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("createTable", StorageProxy.createTable.tupEncoder(table, version), tars_options, StorageProxy.createTable).then(StorageProxy.createTable.tupDecoder, StorageProxy.createTable.errorResponser);
            } else {
                return this._worker.tars_invoke("createTable", StorageProxy.createTable.tarsEncoder(table), tars_options, StorageProxy.createTable).then(StorageProxy.createTable.tarsDecoder, StorageProxy.createTable.errorResponser);
            }
        }

        static del = _castFunctionInfo({
            name: "del",
            return: "int32",
            arguments: [{
                name: "skey",
                class: "Base.StorageKey",
                direction: "in"
            }],
            tarsEncoder(skey: Base.StorageKey) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, skey);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(skey: Base.StorageKey, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("skey", skey);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::del failed");
            }
        })

        del(skey: Base.StorageKey, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("del", StorageProxy.del.tupEncoder(skey, version), tars_options, StorageProxy.del).then(StorageProxy.del.tupDecoder, StorageProxy.del.errorResponser);
            } else {
                return this._worker.tars_invoke("del", StorageProxy.del.tarsEncoder(skey), tars_options, StorageProxy.del).then(StorageProxy.del.tarsDecoder, StorageProxy.del.errorResponser);
            }
        }

        static delBatch = _castFunctionInfo({
            name: "delBatch",
            return: "int32",
            arguments: [{
                name: "skey",
                class: "list(Base.StorageKey)",
                direction: "in"
            }],
            tarsEncoder(skey: TarsStream.List<Base.StorageKey>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeList(1, skey);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(skey: TarsStream.List<Base.StorageKey>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeList("skey", skey);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::delBatch failed");
            }
        })

        delBatch(skey: TarsStream.List<Base.StorageKey>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("delBatch", StorageProxy.delBatch.tupEncoder(skey, version), tars_options, StorageProxy.delBatch).then(StorageProxy.delBatch.tupDecoder, StorageProxy.delBatch.errorResponser);
            } else {
                return this._worker.tars_invoke("delBatch", StorageProxy.delBatch.tarsEncoder(skey), tars_options, StorageProxy.delBatch).then(StorageProxy.delBatch.tarsDecoder, StorageProxy.delBatch.errorResponser);
            }
        }

        static deleteQueue = _castFunctionInfo({
            name: "deleteQueue",
            return: "int32",
            arguments: [{
                name: "queue",
                class: "string",
                direction: "in"
            }],
            tarsEncoder(queue: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, queue);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(queue: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("queue", queue);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::deleteQueue failed");
            }
        })

        deleteQueue(queue: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("deleteQueue", StorageProxy.deleteQueue.tupEncoder(queue, version), tars_options, StorageProxy.deleteQueue).then(StorageProxy.deleteQueue.tupDecoder, StorageProxy.deleteQueue.errorResponser);
            } else {
                return this._worker.tars_invoke("deleteQueue", StorageProxy.deleteQueue.tarsEncoder(queue), tars_options, StorageProxy.deleteQueue).then(StorageProxy.deleteQueue.tarsDecoder, StorageProxy.deleteQueue.errorResponser);
            }
        }

        static deleteQueueData = _castFunctionInfo({
            name: "deleteQueueData",
            return: "int32",
            arguments: [{
                name: "req",
                class: "list(Base.QueueIndex)",
                direction: "in"
            }],
            tarsEncoder(req: TarsStream.List<Base.QueueIndex>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeList(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: TarsStream.List<Base.QueueIndex>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeList("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::deleteQueueData failed");
            }
        })

        deleteQueueData(req: TarsStream.List<Base.QueueIndex>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("deleteQueueData", StorageProxy.deleteQueueData.tupEncoder(req, version), tars_options, StorageProxy.deleteQueueData).then(StorageProxy.deleteQueueData.tupDecoder, StorageProxy.deleteQueueData.errorResponser);
            } else {
                return this._worker.tars_invoke("deleteQueueData", StorageProxy.deleteQueueData.tarsEncoder(req), tars_options, StorageProxy.deleteQueueData).then(StorageProxy.deleteQueueData.tarsDecoder, StorageProxy.deleteQueueData.errorResponser);
            }
        }

        static deleteTable = _castFunctionInfo({
            name: "deleteTable",
            return: "int32",
            arguments: [{
                name: "table",
                class: "string",
                direction: "in"
            }],
            tarsEncoder(table: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, table);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(table: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("table", table);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::deleteTable failed");
            }
        })

        deleteTable(table: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("deleteTable", StorageProxy.deleteTable.tupEncoder(table, version), tars_options, StorageProxy.deleteTable).then(StorageProxy.deleteTable.tupDecoder, StorageProxy.deleteTable.errorResponser);
            } else {
                return this._worker.tars_invoke("deleteTable", StorageProxy.deleteTable.tarsEncoder(table), tars_options, StorageProxy.deleteTable).then(StorageProxy.deleteTable.tarsDecoder, StorageProxy.deleteTable.errorResponser);
            }
        }

        static doBatch = _castFunctionInfo({
            name: "doBatch",
            return: "int32",
            arguments: [{
                name: "req",
                class: "Base.BatchDataReq",
                direction: "in"
            }, {
                name: "rsp",
                class: "Base.BatchDataRsp",
                direction: "out"
            }],
            tarsEncoder(req: Base.BatchDataReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                rsp: is.readStruct(2, true, Base.BatchDataRsp)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: Base.BatchDataReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                rsp: tup.readStruct("rsp", Base.BatchDataRsp)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::doBatch failed");
            }
        })

        doBatch(req: Base.BatchDataReq, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("doBatch", StorageProxy.doBatch.tupEncoder(req, version), tars_options, StorageProxy.doBatch).then(StorageProxy.doBatch.tupDecoder, StorageProxy.doBatch.errorResponser);
            } else {
                return this._worker.tars_invoke("doBatch", StorageProxy.doBatch.tarsEncoder(req), tars_options, StorageProxy.doBatch).then(StorageProxy.doBatch.tarsDecoder, StorageProxy.doBatch.errorResponser);
            }
        }

        static get = _castFunctionInfo({
            name: "get",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "skey",
                class: "Base.StorageKey",
                direction: "in"
            }, {
                name: "data",
                class: "Base.StorageValue",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, skey: Base.StorageKey) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeStruct(2, skey);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                data: is.readStruct(3, true, Base.StorageValue)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, skey: Base.StorageKey, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeStruct("skey", skey);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                data: tup.readStruct("data", Base.StorageValue)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::get failed");
            }
        })

        get(opt: Base.Options, skey: Base.StorageKey, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("get", StorageProxy.get.tupEncoder(opt, skey, version), tars_options, StorageProxy.get).then(StorageProxy.get.tupDecoder, StorageProxy.get.errorResponser);
            } else {
                return this._worker.tars_invoke("get", StorageProxy.get.tarsEncoder(opt, skey), tars_options, StorageProxy.get).then(StorageProxy.get.tarsDecoder, StorageProxy.get.errorResponser);
            }
        }

        static getBatch = _castFunctionInfo({
            name: "getBatch",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "skey",
                class: "list(Base.StorageKey)",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.StorageData)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, skey: TarsStream.List<Base.StorageKey>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeList(2, skey);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                data: is.readList(3, true, TarsStream.List(Base.StorageData))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, skey: TarsStream.List<Base.StorageKey>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeList("skey", skey);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                data: tup.readList("data", TarsStream.List(Base.StorageData))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::getBatch failed");
            }
        })

        getBatch(opt: Base.Options, skey: TarsStream.List<Base.StorageKey>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getBatch", StorageProxy.getBatch.tupEncoder(opt, skey, version), tars_options, StorageProxy.getBatch).then(StorageProxy.getBatch.tupDecoder, StorageProxy.getBatch.errorResponser);
            } else {
                return this._worker.tars_invoke("getBatch", StorageProxy.getBatch.tarsEncoder(opt, skey), tars_options, StorageProxy.getBatch).then(StorageProxy.getBatch.tarsDecoder, StorageProxy.getBatch.errorResponser);
            }
        }

        static getQueueData = _castFunctionInfo({
            name: "getQueueData",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "list(Base.QueueIndex)",
                direction: "in"
            }, {
                name: "rsp",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, req: TarsStream.List<Base.QueueIndex>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeList(2, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                rsp: is.readList(3, true, TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, req: TarsStream.List<Base.QueueIndex>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeList("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                rsp: tup.readList("rsp", TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::getQueueData failed");
            }
        })

        getQueueData(opt: Base.Options, req: TarsStream.List<Base.QueueIndex>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getQueueData", StorageProxy.getQueueData.tupEncoder(opt, req, version), tars_options, StorageProxy.getQueueData).then(StorageProxy.getQueueData.tupDecoder, StorageProxy.getQueueData.errorResponser);
            } else {
                return this._worker.tars_invoke("getQueueData", StorageProxy.getQueueData.tarsEncoder(opt, req), tars_options, StorageProxy.getQueueData).then(StorageProxy.getQueueData.tarsDecoder, StorageProxy.getQueueData.errorResponser);
            }
        }

        static get_queue = _castFunctionInfo({
            name: "get_queue",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "Base.QueuePopReq",
                direction: "in"
            }, {
                name: "rsp",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, req: Base.QueuePopReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeStruct(2, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                rsp: is.readList(3, true, TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, req: Base.QueuePopReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                rsp: tup.readList("rsp", TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::get_queue failed");
            }
        })

        get_queue(opt: Base.Options, req: Base.QueuePopReq, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("get_queue", StorageProxy.get_queue.tupEncoder(opt, req, version), tars_options, StorageProxy.get_queue).then(StorageProxy.get_queue.tupDecoder, StorageProxy.get_queue.errorResponser);
            } else {
                return this._worker.tars_invoke("get_queue", StorageProxy.get_queue.tarsEncoder(opt, req), tars_options, StorageProxy.get_queue).then(StorageProxy.get_queue.tarsDecoder, StorageProxy.get_queue.errorResponser);
            }
        }

        static has = _castFunctionInfo({
            name: "has",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "skey",
                class: "Base.StorageKey",
                direction: "in"
            }],
            tarsEncoder(opt: Base.Options, skey: Base.StorageKey) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeStruct(2, skey);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, skey: Base.StorageKey, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeStruct("skey", skey);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::has failed");
            }
        })

        has(opt: Base.Options, skey: Base.StorageKey, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("has", StorageProxy.has.tupEncoder(opt, skey, version), tars_options, StorageProxy.has).then(StorageProxy.has.tupDecoder, StorageProxy.has.errorResponser);
            } else {
                return this._worker.tars_invoke("has", StorageProxy.has.tarsEncoder(opt, skey), tars_options, StorageProxy.has).then(StorageProxy.has.tarsDecoder, StorageProxy.has.errorResponser);
            }
        }

        static hasBatch = _castFunctionInfo({
            name: "hasBatch",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.StorageKey)",
                direction: "in"
            }, {
                name: "rsp",
                class: "map(Base.StorageKey, int32)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, data: TarsStream.List<Base.StorageKey>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeList(2, data);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                rsp: is.readMap(3, true, TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, data: TarsStream.List<Base.StorageKey>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeList("data", data);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                rsp: tup.readMap("rsp", TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::hasBatch failed");
            }
        })

        hasBatch(opt: Base.Options, data: TarsStream.List<Base.StorageKey>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasBatch", StorageProxy.hasBatch.tupEncoder(opt, data, version), tars_options, StorageProxy.hasBatch).then(StorageProxy.hasBatch.tupDecoder, StorageProxy.hasBatch.errorResponser);
            } else {
                return this._worker.tars_invoke("hasBatch", StorageProxy.hasBatch.tarsEncoder(opt, data), tars_options, StorageProxy.hasBatch).then(StorageProxy.hasBatch.tarsDecoder, StorageProxy.hasBatch.errorResponser);
            }
        }

        static listQueue = _castFunctionInfo({
            name: "listQueue",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "queues",
                class: "list(string)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                queues: is.readList(2, true, TarsStream.List(TarsStream.String))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                queues: tup.readList("queues", TarsStream.List(TarsStream.String))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::listQueue failed");
            }
        })

        listQueue(opt: Base.Options, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("listQueue", StorageProxy.listQueue.tupEncoder(opt, version), tars_options, StorageProxy.listQueue).then(StorageProxy.listQueue.tupDecoder, StorageProxy.listQueue.errorResponser);
            } else {
                return this._worker.tars_invoke("listQueue", StorageProxy.listQueue.tarsEncoder(opt), tars_options, StorageProxy.listQueue).then(StorageProxy.listQueue.tarsDecoder, StorageProxy.listQueue.errorResponser);
            }
        }

        static listTable = _castFunctionInfo({
            name: "listTable",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "tables",
                class: "list(string)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                tables: is.readList(2, true, TarsStream.List(TarsStream.String))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                tables: tup.readList("tables", TarsStream.List(TarsStream.String))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::listTable failed");
            }
        })

        listTable(opt: Base.Options, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("listTable", StorageProxy.listTable.tupEncoder(opt, version), tars_options, StorageProxy.listTable).then(StorageProxy.listTable.tupDecoder, StorageProxy.listTable.errorResponser);
            } else {
                return this._worker.tars_invoke("listTable", StorageProxy.listTable.tarsEncoder(opt), tars_options, StorageProxy.listTable).then(StorageProxy.listTable.tarsDecoder, StorageProxy.listTable.errorResponser);
            }
        }

        static pop_queue = _castFunctionInfo({
            name: "pop_queue",
            return: "int32",
            arguments: [{
                name: "req",
                class: "Base.QueuePopReq",
                direction: "in"
            }, {
                name: "rsp",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
            tarsEncoder(req: Base.QueuePopReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                rsp: is.readList(2, true, TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: Base.QueuePopReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                rsp: tup.readList("rsp", TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::pop_queue failed");
            }
        })

        pop_queue(req: Base.QueuePopReq, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("pop_queue", StorageProxy.pop_queue.tupEncoder(req, version), tars_options, StorageProxy.pop_queue).then(StorageProxy.pop_queue.tupDecoder, StorageProxy.pop_queue.errorResponser);
            } else {
                return this._worker.tars_invoke("pop_queue", StorageProxy.pop_queue.tarsEncoder(req), tars_options, StorageProxy.pop_queue).then(StorageProxy.pop_queue.tarsDecoder, StorageProxy.pop_queue.errorResponser);
            }
        }

        static push_queue = _castFunctionInfo({
            name: "push_queue",
            return: "int32",
            arguments: [{
                name: "req",
                class: "list(Base.QueuePushReq)",
                direction: "in"
            }],
            tarsEncoder(req: TarsStream.List<Base.QueuePushReq>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeList(1, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(req: TarsStream.List<Base.QueuePushReq>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeList("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::push_queue failed");
            }
        })

        push_queue(req: TarsStream.List<Base.QueuePushReq>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("push_queue", StorageProxy.push_queue.tupEncoder(req, version), tars_options, StorageProxy.push_queue).then(StorageProxy.push_queue.tupDecoder, StorageProxy.push_queue.errorResponser);
            } else {
                return this._worker.tars_invoke("push_queue", StorageProxy.push_queue.tarsEncoder(req), tars_options, StorageProxy.push_queue).then(StorageProxy.push_queue.tarsDecoder, StorageProxy.push_queue.errorResponser);
            }
        }

        static set = _castFunctionInfo({
            name: "set",
            return: "int32",
            arguments: [{
                name: "data",
                class: "Base.StorageData",
                direction: "in"
            }],
            tarsEncoder(data: Base.StorageData) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, data);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(data: Base.StorageData, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("data", data);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::set failed");
            }
        })

        set(data: Base.StorageData, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("set", StorageProxy.set.tupEncoder(data, version), tars_options, StorageProxy.set).then(StorageProxy.set.tupDecoder, StorageProxy.set.errorResponser);
            } else {
                return this._worker.tars_invoke("set", StorageProxy.set.tarsEncoder(data), tars_options, StorageProxy.set).then(StorageProxy.set.tarsDecoder, StorageProxy.set.errorResponser);
            }
        }

        static setBatch = _castFunctionInfo({
            name: "setBatch",
            return: "int32",
            arguments: [{
                name: "data",
                class: "list(Base.StorageData)",
                direction: "in"
            }, {
                name: "rsp",
                class: "map(Base.StorageKey, int32)",
                direction: "out"
            }],
            tarsEncoder(data: TarsStream.List<Base.StorageData>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeList(1, data);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                rsp: is.readMap(2, true, TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(data: TarsStream.List<Base.StorageData>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeList("data", data);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                rsp: tup.readMap("rsp", TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::setBatch failed");
            }
        })

        setBatch(data: TarsStream.List<Base.StorageData>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("setBatch", StorageProxy.setBatch.tupEncoder(data, version), tars_options, StorageProxy.setBatch).then(StorageProxy.setBatch.tupDecoder, StorageProxy.setBatch.errorResponser);
            } else {
                return this._worker.tars_invoke("setBatch", StorageProxy.setBatch.tarsEncoder(data), tars_options, StorageProxy.setBatch).then(StorageProxy.setBatch.tarsDecoder, StorageProxy.setBatch.errorResponser);
            }
        }

        static setQueueData = _castFunctionInfo({
            name: "setQueueData",
            return: "int32",
            arguments: [{
                name: "data",
                class: "list(Base.QueueRsp)",
                direction: "in"
            }],
            tarsEncoder(data: TarsStream.List<Base.QueueRsp>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeList(1, data);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(data: TarsStream.List<Base.QueueRsp>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeList("data", data);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::setQueueData failed");
            }
        })

        setQueueData(data: TarsStream.List<Base.QueueRsp>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("setQueueData", StorageProxy.setQueueData.tupEncoder(data, version), tars_options, StorageProxy.setQueueData).then(StorageProxy.setQueueData.tupDecoder, StorageProxy.setQueueData.errorResponser);
            } else {
                return this._worker.tars_invoke("setQueueData", StorageProxy.setQueueData.tarsEncoder(data), tars_options, StorageProxy.setQueueData).then(StorageProxy.setQueueData.tarsDecoder, StorageProxy.setQueueData.errorResponser);
            }
        }

        static tars_ping = _castFunctionInfo({
            name: "tars_ping",
            return: "void",
            arguments: [],
            tarsEncoder() {
                const os = new TarsStream.TarsOutputStream();
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: undefined as undefined,
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(__$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: undefined as undefined,
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::tars_ping failed");
            }
        })

        tars_ping(tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("tars_ping", StorageProxy.tars_ping.tupEncoder(version), tars_options, StorageProxy.tars_ping).then(StorageProxy.tars_ping.tupDecoder, StorageProxy.tars_ping.errorResponser);
            } else {
                return this._worker.tars_invoke("tars_ping", StorageProxy.tars_ping.tarsEncoder(), tars_options, StorageProxy.tars_ping).then(StorageProxy.tars_ping.tarsDecoder, StorageProxy.tars_ping.errorResponser);
            }
        }

        static trans = _castFunctionInfo({
            name: "trans",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "Base.PageReq",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.StorageData)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, req: Base.PageReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeStruct(2, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                data: is.readList(3, true, TarsStream.List(Base.StorageData))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, req: Base.PageReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                data: tup.readList("data", TarsStream.List(Base.StorageData))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::trans failed");
            }
        })

        trans(opt: Base.Options, req: Base.PageReq, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("trans", StorageProxy.trans.tupEncoder(opt, req, version), tars_options, StorageProxy.trans).then(StorageProxy.trans.tupDecoder, StorageProxy.trans.errorResponser);
            } else {
                return this._worker.tars_invoke("trans", StorageProxy.trans.tarsEncoder(opt, req), tars_options, StorageProxy.trans).then(StorageProxy.trans.tarsDecoder, StorageProxy.trans.errorResponser);
            }
        }

        static transQueue = _castFunctionInfo({
            name: "transQueue",
            return: "int32",
            arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "Base.QueuePageReq",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
            tarsEncoder(opt: Base.Options, req: Base.QueuePageReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, opt);
                os.writeStruct(2, req);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                data: is.readList(3, true, TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(opt: Base.Options, req: Base.QueuePageReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("opt", opt);
                tup.writeStruct("req", req);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                data: tup.readList("data", TarsStream.List(Base.QueueRsp))
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::transQueue failed");
            }
        })

        transQueue(opt: Base.Options, req: Base.QueuePageReq, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("transQueue", StorageProxy.transQueue.tupEncoder(opt, req, version), tars_options, StorageProxy.transQueue).then(StorageProxy.transQueue.tupDecoder, StorageProxy.transQueue.errorResponser);
            } else {
                return this._worker.tars_invoke("transQueue", StorageProxy.transQueue.tarsEncoder(opt, req), tars_options, StorageProxy.transQueue).then(StorageProxy.transQueue.tarsDecoder, StorageProxy.transQueue.errorResponser);
            }
        }

        static update = _castFunctionInfo({
            name: "update",
            return: "int32",
            arguments: [{
                name: "data",
                class: "Base.StorageJson",
                direction: "in"
            }],
            tarsEncoder(data: Base.StorageJson) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, data);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(data: Base.StorageJson, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("data", data);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::update failed");
            }
        })

        update(data: Base.StorageJson, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("update", StorageProxy.update.tupEncoder(data, version), tars_options, StorageProxy.update).then(StorageProxy.update.tupDecoder, StorageProxy.update.errorResponser);
            } else {
                return this._worker.tars_invoke("update", StorageProxy.update.tarsEncoder(data), tars_options, StorageProxy.update).then(StorageProxy.update.tarsDecoder, StorageProxy.update.errorResponser);
            }
        }

        static updateBatch = _castFunctionInfo({
            name: "updateBatch",
            return: "int32",
            arguments: [{
                name: "data",
                class: "list(Base.StorageJson)",
                direction: "in"
            }],
            tarsEncoder(data: TarsStream.List<Base.StorageJson>) {
                const os = new TarsStream.TarsOutputStream();
                os.writeList(1, data);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(data: TarsStream.List<Base.StorageJson>, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeList("data", data);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Storage::updateBatch failed");
            }
        })

        updateBatch(data: TarsStream.List<Base.StorageJson>, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("updateBatch", StorageProxy.updateBatch.tupEncoder(data, version), tars_options, StorageProxy.updateBatch).then(StorageProxy.updateBatch.tupDecoder, StorageProxy.updateBatch.errorResponser);
            } else {
                return this._worker.tars_invoke("updateBatch", StorageProxy.updateBatch.tarsEncoder(data), tars_options, StorageProxy.updateBatch).then(StorageProxy.updateBatch.tarsDecoder, StorageProxy.updateBatch.errorResponser);
            }
        }


    }

}


