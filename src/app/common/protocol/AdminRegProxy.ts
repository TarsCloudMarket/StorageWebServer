// **********************************************************************
// Parsed By TarsParser(3.0.12), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "AdminReg.tars" by Client Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";
import * as TarsRpc from "@tars/rpc";

const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo<Ret, Arg>(data: SharedFunctionInfo<Ret, Arg>) { return data; }
function _makeError(data: TarsRpc.RpcResponse, message: string, type?: number): TarsRpc.RpcError {
    var error: any = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    } else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}

export interface SharedFunctionInfo<Ret = any, Arg = any> extends TarsRpc.SharedFunctionInfo {
    tarsEncoder (...args: any[]): TarsStream.BinBuffer,
    tarsDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    tupEncoder (...args: any[]): TarsStream.UniAttribute,
    tupDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    errorResponser (data: TarsRpc.RpcResponse): never
}

export namespace tars {
    export enum tarsErrCode {
        EM_TARS_NODE_NOT_REGISTRY_ERR = 1001,
        EM_TARS_CALL_NODE_TIMEOUT_ERR = 1002,
        EM_TARS_LOAD_SERVICE_DESC_ERR = 1003,
        EM_TARS_SERVICE_STATE_ERR = 1004,
        EM_TARS_REQ_ALREADY_ERR = 1005,
        EM_TARS_INVALID_IP_ERR = 1006,
        EM_TARS_PARAMETER_ERR = 1007,
        EM_TARS_OTHER_ERR = 1008,
        EM_TARS_GET_PATCH_FILE_ERR = 1009,
        EM_TARS_PREPARE_ERR = 1010,
        EM_TARS_CAN_NOT_EXECUTE = 1011,
        EM_TARS_NODE_NO_CONNECTION = 1012,
        EM_TARS_UNKNOWN_ERR = -1,
        EM_TARS_SUCCESS = 0
    }

    export namespace tarsErrCode {
        export const _classname = "tars.tarsErrCode";
        export function _write(os: TarsStream.TarsOutputStream, tag: number, val: number) { return os.writeInt32(tag, val); }
        export function _read(is: TarsStream.TarsInputStream, tag: number, def?: number) { return is.readInt32(tag, true, def); }
    }


    export class PluginConf {
        name: string = "";
        name_en: string = "";
        obj: string = "";
        type: number = 0;
        path: string = "";
        k8s: boolean = true;

        protected _proto_struct_name_ = "";
        protected _classname = "tars.PluginConf";
        protected static _classname = "tars.PluginConf";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new PluginConf;
            tmp.name = is.readString(0, false, "");
            tmp.name_en = is.readString(1, false, "");
            tmp.obj = is.readString(2, false, "");
            tmp.type = is.readInt32(3, false, 0);
            tmp.path = is.readString(4, false, "");
            tmp.k8s = is.readBoolean(5, false, true);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.name);
            os.writeString(1, this.name_en);
            os.writeString(2, this.obj);
            os.writeInt32(3, this.type);
            os.writeString(4, this.path);
            os.writeBoolean(5, this.k8s);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): PluginConf.Object { 
            return {
                name: this.name,
                name_en: this.name_en,
                obj: this.obj,
                type: this.type,
                path: this.path,
                k8s: this.k8s
            };
        }

        readFromObject(json: PluginConf.Object) { 
            _hasOwnProperty.call(json, "name") && (this.name = json.name!);
            _hasOwnProperty.call(json, "name_en") && (this.name_en = json.name_en!);
            _hasOwnProperty.call(json, "obj") && (this.obj = json.obj!);
            _hasOwnProperty.call(json, "type") && (this.type = json.type!);
            _hasOwnProperty.call(json, "path") && (this.path = json.path!);
            _hasOwnProperty.call(json, "k8s") && (this.k8s = json.k8s!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new PluginConf();
        }

        static create(is: TarsStream.TarsInputStream) {
            return tars.PluginConf._readFrom(is);
        }
    }

    export namespace PluginConf {
        export interface Object {
            name?: string;
            name_en?: string;
            obj?: string;
            type?: number;
            path?: string;
            k8s?: boolean;
        }
    }

    export class AuthConf {
        flag: string = "";
        role: string = "";
        uid: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "tars.AuthConf";
        protected static _classname = "tars.AuthConf";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new AuthConf;
            tmp.flag = is.readString(0, false, "");
            tmp.role = is.readString(1, false, "");
            tmp.uid = is.readString(2, false, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.flag);
            os.writeString(1, this.role);
            os.writeString(2, this.uid);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): AuthConf.Object { 
            return {
                flag: this.flag,
                role: this.role,
                uid: this.uid
            };
        }

        readFromObject(json: AuthConf.Object) { 
            _hasOwnProperty.call(json, "flag") && (this.flag = json.flag!);
            _hasOwnProperty.call(json, "role") && (this.role = json.role!);
            _hasOwnProperty.call(json, "uid") && (this.uid = json.uid!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new AuthConf();
        }

        static create(is: TarsStream.TarsInputStream) {
            return tars.AuthConf._readFrom(is);
        }
    }

    export namespace AuthConf {
        export interface Object {
            flag?: string;
            role?: string;
            uid?: string;
        }
    }

    export class AuthConfList {
        auths: TarsStream.List<tars.AuthConf> = new TarsStream.List(tars.AuthConf);

        protected _proto_struct_name_ = "";
        protected _classname = "tars.AuthConfList";
        protected static _classname = "tars.AuthConfList";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new AuthConfList;
            tmp.auths = is.readList(0, false, TarsStream.List(tars.AuthConf));
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeList(0, this.auths);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): AuthConfList.Object { 
            return {
                auths: this.auths.toObject()
            };
        }

        readFromObject(json: AuthConfList.Object) { 
            _hasOwnProperty.call(json, "auths") && (this.auths.readFromObject(json.auths!));
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new AuthConfList();
        }

        static create(is: TarsStream.TarsInputStream) {
            return tars.AuthConfList._readFrom(is);
        }
    }

    export namespace AuthConfList {
        export interface Object {
            auths?: Array<tars.AuthConf.Object>;
        }
    }

    export class AdminRegProxy {
        protected _name!: string
        protected _worker!: TarsRpc.ObjectProxy

        setTimeout (iTimeout: number) { this._worker.timeout = iTimeout; }
        getTimeout () { return this._worker.timeout; }
        setVersion (iVersion: number) { this._worker.version = iVersion; }
        getVersion () { return this._worker.version; }

        static checkTicket = _castFunctionInfo({
            name: "checkTicket",
            return: "int32",
            arguments: [{
                name: "ticket",
                class: "string",
                direction: "in"
            }, {
                name: "uid",
                class: "string",
                direction: "out"
            }],
            tarsEncoder(ticket: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, ticket);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                uid: is.readString(2, true, "")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(ticket: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("ticket", ticket);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                uid: tup.readString("uid")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::checkTicket failed");
            }
        })

        checkTicket(ticket: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("checkTicket", AdminRegProxy.checkTicket.tupEncoder(ticket, version), tars_options, AdminRegProxy.checkTicket).then(AdminRegProxy.checkTicket.tupDecoder, AdminRegProxy.checkTicket.errorResponser);
            } else {
                return this._worker.tars_invoke("checkTicket", AdminRegProxy.checkTicket.tarsEncoder(ticket), tars_options, AdminRegProxy.checkTicket).then(AdminRegProxy.checkTicket.tarsDecoder, AdminRegProxy.checkTicket.errorResponser);
            }
        }

        static hasAdminAuth = _castFunctionInfo({
            name: "hasAdminAuth",
            return: "int32",
            arguments: [{
                name: "uid",
                class: "string",
                direction: "in"
            }, {
                name: "has",
                class: "bool",
                direction: "out"
            }],
            tarsEncoder(uid: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, uid);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                has: is.readBoolean(2, true, true)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(uid: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("uid", uid);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                has: tup.readBoolean("has")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::hasAdminAuth failed");
            }
        })

        hasAdminAuth(uid: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasAdminAuth", AdminRegProxy.hasAdminAuth.tupEncoder(uid, version), tars_options, AdminRegProxy.hasAdminAuth).then(AdminRegProxy.hasAdminAuth.tupDecoder, AdminRegProxy.hasAdminAuth.errorResponser);
            } else {
                return this._worker.tars_invoke("hasAdminAuth", AdminRegProxy.hasAdminAuth.tarsEncoder(uid), tars_options, AdminRegProxy.hasAdminAuth).then(AdminRegProxy.hasAdminAuth.tarsDecoder, AdminRegProxy.hasAdminAuth.errorResponser);
            }
        }

        static hasDevAuth = _castFunctionInfo({
            name: "hasDevAuth",
            return: "int32",
            arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "uid",
                class: "string",
                direction: "in"
            }, {
                name: "has",
                class: "bool",
                direction: "out"
            }],
            tarsEncoder(application: string, serverName: string, uid: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, application);
                os.writeString(2, serverName);
                os.writeString(3, uid);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                has: is.readBoolean(4, true, true)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(application: string, serverName: string, uid: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("application", application);
                tup.writeString("serverName", serverName);
                tup.writeString("uid", uid);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                has: tup.readBoolean("has")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::hasDevAuth failed");
            }
        })

        hasDevAuth(application: string, serverName: string, uid: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasDevAuth", AdminRegProxy.hasDevAuth.tupEncoder(application, serverName, uid, version), tars_options, AdminRegProxy.hasDevAuth).then(AdminRegProxy.hasDevAuth.tupDecoder, AdminRegProxy.hasDevAuth.errorResponser);
            } else {
                return this._worker.tars_invoke("hasDevAuth", AdminRegProxy.hasDevAuth.tarsEncoder(application, serverName, uid), tars_options, AdminRegProxy.hasDevAuth).then(AdminRegProxy.hasDevAuth.tarsDecoder, AdminRegProxy.hasDevAuth.errorResponser);
            }
        }

        static hasOpeAuth = _castFunctionInfo({
            name: "hasOpeAuth",
            return: "int32",
            arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "uid",
                class: "string",
                direction: "in"
            }, {
                name: "has",
                class: "bool",
                direction: "out"
            }],
            tarsEncoder(application: string, serverName: string, uid: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, application);
                os.writeString(2, serverName);
                os.writeString(3, uid);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                has: is.readBoolean(4, true, true)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(application: string, serverName: string, uid: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("application", application);
                tup.writeString("serverName", serverName);
                tup.writeString("uid", uid);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                has: tup.readBoolean("has")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::hasOpeAuth failed");
            }
        })

        hasOpeAuth(application: string, serverName: string, uid: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasOpeAuth", AdminRegProxy.hasOpeAuth.tupEncoder(application, serverName, uid, version), tars_options, AdminRegProxy.hasOpeAuth).then(AdminRegProxy.hasOpeAuth.tupDecoder, AdminRegProxy.hasOpeAuth.errorResponser);
            } else {
                return this._worker.tars_invoke("hasOpeAuth", AdminRegProxy.hasOpeAuth.tarsEncoder(application, serverName, uid), tars_options, AdminRegProxy.hasOpeAuth).then(AdminRegProxy.hasOpeAuth.tarsDecoder, AdminRegProxy.hasOpeAuth.errorResponser);
            }
        }

        static notifyServer = _castFunctionInfo({
            name: "notifyServer",
            return: "int32",
            arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "command",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
            tarsEncoder(application: string, serverName: string, nodeName: string, command: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, application);
                os.writeString(2, serverName);
                os.writeString(3, nodeName);
                os.writeString(4, command);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                result: is.readString(5, true, "")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(application: string, serverName: string, nodeName: string, command: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("application", application);
                tup.writeString("serverName", serverName);
                tup.writeString("nodeName", nodeName);
                tup.writeString("command", command);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                result: tup.readString("result")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::notifyServer failed");
            }
        })

        notifyServer(application: string, serverName: string, nodeName: string, command: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("notifyServer", AdminRegProxy.notifyServer.tupEncoder(application, serverName, nodeName, command, version), tars_options, AdminRegProxy.notifyServer).then(AdminRegProxy.notifyServer.tupDecoder, AdminRegProxy.notifyServer.errorResponser);
            } else {
                return this._worker.tars_invoke("notifyServer", AdminRegProxy.notifyServer.tarsEncoder(application, serverName, nodeName, command), tars_options, AdminRegProxy.notifyServer).then(AdminRegProxy.notifyServer.tarsDecoder, AdminRegProxy.notifyServer.errorResponser);
            }
        }

        static pingNode = _castFunctionInfo({
            name: "pingNode",
            return: "bool",
            arguments: [{
                name: "name",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
            tarsEncoder(name: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, name);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readBoolean(0, true, true),
                            arguments: {
                                result: is.readString(2, true, "")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(name: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("name", name);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readBoolean("", false),
                            arguments: {
                                result: tup.readString("result")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::pingNode failed");
            }
        })

        pingNode(name: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("pingNode", AdminRegProxy.pingNode.tupEncoder(name, version), tars_options, AdminRegProxy.pingNode).then(AdminRegProxy.pingNode.tupDecoder, AdminRegProxy.pingNode.errorResponser);
            } else {
                return this._worker.tars_invoke("pingNode", AdminRegProxy.pingNode.tarsEncoder(name), tars_options, AdminRegProxy.pingNode).then(AdminRegProxy.pingNode.tarsDecoder, AdminRegProxy.pingNode.errorResponser);
            }
        }

        static registerPlugin = _castFunctionInfo({
            name: "registerPlugin",
            return: "int32",
            arguments: [{
                name: "conf",
                class: "tars.PluginConf",
                direction: "in"
            }],
            tarsEncoder(conf: tars.PluginConf) {
                const os = new TarsStream.TarsOutputStream();
                os.writeStruct(1, conf);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(conf: tars.PluginConf, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeStruct("conf", conf);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::registerPlugin failed");
            }
        })

        registerPlugin(conf: tars.PluginConf, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("registerPlugin", AdminRegProxy.registerPlugin.tupEncoder(conf, version), tars_options, AdminRegProxy.registerPlugin).then(AdminRegProxy.registerPlugin.tupDecoder, AdminRegProxy.registerPlugin.errorResponser);
            } else {
                return this._worker.tars_invoke("registerPlugin", AdminRegProxy.registerPlugin.tarsEncoder(conf), tars_options, AdminRegProxy.registerPlugin).then(AdminRegProxy.registerPlugin.tarsDecoder, AdminRegProxy.registerPlugin.errorResponser);
            }
        }

        static restartServer = _castFunctionInfo({
            name: "restartServer",
            return: "int32",
            arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
            tarsEncoder(application: string, serverName: string, nodeName: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, application);
                os.writeString(2, serverName);
                os.writeString(3, nodeName);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                result: is.readString(4, true, "")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(application: string, serverName: string, nodeName: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("application", application);
                tup.writeString("serverName", serverName);
                tup.writeString("nodeName", nodeName);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                result: tup.readString("result")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::restartServer failed");
            }
        })

        restartServer(application: string, serverName: string, nodeName: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("restartServer", AdminRegProxy.restartServer.tupEncoder(application, serverName, nodeName, version), tars_options, AdminRegProxy.restartServer).then(AdminRegProxy.restartServer.tupDecoder, AdminRegProxy.restartServer.errorResponser);
            } else {
                return this._worker.tars_invoke("restartServer", AdminRegProxy.restartServer.tarsEncoder(application, serverName, nodeName), tars_options, AdminRegProxy.restartServer).then(AdminRegProxy.restartServer.tarsDecoder, AdminRegProxy.restartServer.errorResponser);
            }
        }

        static startServer = _castFunctionInfo({
            name: "startServer",
            return: "int32",
            arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
            tarsEncoder(application: string, serverName: string, nodeName: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, application);
                os.writeString(2, serverName);
                os.writeString(3, nodeName);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                result: is.readString(4, true, "")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(application: string, serverName: string, nodeName: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("application", application);
                tup.writeString("serverName", serverName);
                tup.writeString("nodeName", nodeName);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                result: tup.readString("result")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::startServer failed");
            }
        })

        startServer(application: string, serverName: string, nodeName: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("startServer", AdminRegProxy.startServer.tupEncoder(application, serverName, nodeName, version), tars_options, AdminRegProxy.startServer).then(AdminRegProxy.startServer.tupDecoder, AdminRegProxy.startServer.errorResponser);
            } else {
                return this._worker.tars_invoke("startServer", AdminRegProxy.startServer.tarsEncoder(application, serverName, nodeName), tars_options, AdminRegProxy.startServer).then(AdminRegProxy.startServer.tarsDecoder, AdminRegProxy.startServer.errorResponser);
            }
        }

        static stopServer = _castFunctionInfo({
            name: "stopServer",
            return: "int32",
            arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
            tarsEncoder(application: string, serverName: string, nodeName: string) {
                const os = new TarsStream.TarsOutputStream();
                os.writeString(1, application);
                os.writeString(2, serverName);
                os.writeString(3, nodeName);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                result: is.readString(4, true, "")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(application: string, serverName: string, nodeName: string, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeString("application", application);
                tup.writeString("serverName", serverName);
                tup.writeString("nodeName", nodeName);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                result: tup.readString("result")
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::stopServer failed");
            }
        })

        stopServer(application: string, serverName: string, nodeName: string, tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("stopServer", AdminRegProxy.stopServer.tupEncoder(application, serverName, nodeName, version), tars_options, AdminRegProxy.stopServer).then(AdminRegProxy.stopServer.tupDecoder, AdminRegProxy.stopServer.errorResponser);
            } else {
                return this._worker.tars_invoke("stopServer", AdminRegProxy.stopServer.tarsEncoder(application, serverName, nodeName), tars_options, AdminRegProxy.stopServer).then(AdminRegProxy.stopServer.tarsDecoder, AdminRegProxy.stopServer.errorResponser);
            }
        }

        static tars_ping = _castFunctionInfo({
            name: "tars_ping",
            return: "void",
            arguments: [],
            tarsEncoder() {
                const os = new TarsStream.TarsOutputStream();
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: undefined as undefined,
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(__$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: undefined as undefined,
                            arguments: undefined as undefined
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call AdminReg::tars_ping failed");
            }
        })

        tars_ping(tars_options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("tars_ping", AdminRegProxy.tars_ping.tupEncoder(version), tars_options, AdminRegProxy.tars_ping).then(AdminRegProxy.tars_ping.tupDecoder, AdminRegProxy.tars_ping.errorResponser);
            } else {
                return this._worker.tars_invoke("tars_ping", AdminRegProxy.tars_ping.tarsEncoder(), tars_options, AdminRegProxy.tars_ping).then(AdminRegProxy.tars_ping.tarsDecoder, AdminRegProxy.tars_ping.errorResponser);
            }
        }


    }

}


