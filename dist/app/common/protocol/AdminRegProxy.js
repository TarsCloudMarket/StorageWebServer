"use strict";
// **********************************************************************
// Parsed By TarsParser(3.0.12), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "AdminReg.tars" by Client Mode
// **********************************************************************
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tars = void 0;
/* tslint:disable */
/* eslint-disable */
/// <reference types="node" />
const assert = require("assert");
const TarsStream = __importStar(require("@tars/stream"));
const TarsRpc = __importStar(require("@tars/rpc"));
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo(data) { return data; }
function _makeError(data, message, type) {
    var error = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    }
    else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}
var tars;
(function (tars) {
    let tarsErrCode;
    (function (tarsErrCode) {
        tarsErrCode[tarsErrCode["EM_TARS_NODE_NOT_REGISTRY_ERR"] = 1001] = "EM_TARS_NODE_NOT_REGISTRY_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_CALL_NODE_TIMEOUT_ERR"] = 1002] = "EM_TARS_CALL_NODE_TIMEOUT_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_LOAD_SERVICE_DESC_ERR"] = 1003] = "EM_TARS_LOAD_SERVICE_DESC_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_SERVICE_STATE_ERR"] = 1004] = "EM_TARS_SERVICE_STATE_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_REQ_ALREADY_ERR"] = 1005] = "EM_TARS_REQ_ALREADY_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_INVALID_IP_ERR"] = 1006] = "EM_TARS_INVALID_IP_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_PARAMETER_ERR"] = 1007] = "EM_TARS_PARAMETER_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_OTHER_ERR"] = 1008] = "EM_TARS_OTHER_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_GET_PATCH_FILE_ERR"] = 1009] = "EM_TARS_GET_PATCH_FILE_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_PREPARE_ERR"] = 1010] = "EM_TARS_PREPARE_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_CAN_NOT_EXECUTE"] = 1011] = "EM_TARS_CAN_NOT_EXECUTE";
        tarsErrCode[tarsErrCode["EM_TARS_NODE_NO_CONNECTION"] = 1012] = "EM_TARS_NODE_NO_CONNECTION";
        tarsErrCode[tarsErrCode["EM_TARS_UNKNOWN_ERR"] = -1] = "EM_TARS_UNKNOWN_ERR";
        tarsErrCode[tarsErrCode["EM_TARS_SUCCESS"] = 0] = "EM_TARS_SUCCESS";
    })(tarsErrCode = tars.tarsErrCode || (tars.tarsErrCode = {}));
    (function (tarsErrCode) {
        tarsErrCode._classname = "tars.tarsErrCode";
        function _write(os, tag, val) { return os.writeInt32(tag, val); }
        tarsErrCode._write = _write;
        function _read(is, tag, def) { return is.readInt32(tag, true, def); }
        tarsErrCode._read = _read;
    })(tarsErrCode = tars.tarsErrCode || (tars.tarsErrCode = {}));
    class PluginConf {
        constructor() {
            this.name = "";
            this.name_en = "";
            this.obj = "";
            this.type = 0;
            this.path = "";
            this.k8s = true;
            this._proto_struct_name_ = "";
            this._classname = "tars.PluginConf";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new PluginConf;
            tmp.name = is.readString(0, false, "");
            tmp.name_en = is.readString(1, false, "");
            tmp.obj = is.readString(2, false, "");
            tmp.type = is.readInt32(3, false, 0);
            tmp.path = is.readString(4, false, "");
            tmp.k8s = is.readBoolean(5, false, true);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.name);
            os.writeString(1, this.name_en);
            os.writeString(2, this.obj);
            os.writeInt32(3, this.type);
            os.writeString(4, this.path);
            os.writeBoolean(5, this.k8s);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                name: this.name,
                name_en: this.name_en,
                obj: this.obj,
                type: this.type,
                path: this.path,
                k8s: this.k8s
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "name") && (this.name = json.name);
            _hasOwnProperty.call(json, "name_en") && (this.name_en = json.name_en);
            _hasOwnProperty.call(json, "obj") && (this.obj = json.obj);
            _hasOwnProperty.call(json, "type") && (this.type = json.type);
            _hasOwnProperty.call(json, "path") && (this.path = json.path);
            _hasOwnProperty.call(json, "k8s") && (this.k8s = json.k8s);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new PluginConf();
        }
        static create(is) {
            return tars.PluginConf._readFrom(is);
        }
    }
    PluginConf._classname = "tars.PluginConf";
    tars.PluginConf = PluginConf;
    class AuthConf {
        constructor() {
            this.flag = "";
            this.role = "";
            this.uid = "";
            this._proto_struct_name_ = "";
            this._classname = "tars.AuthConf";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new AuthConf;
            tmp.flag = is.readString(0, false, "");
            tmp.role = is.readString(1, false, "");
            tmp.uid = is.readString(2, false, "");
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.flag);
            os.writeString(1, this.role);
            os.writeString(2, this.uid);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                flag: this.flag,
                role: this.role,
                uid: this.uid
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "flag") && (this.flag = json.flag);
            _hasOwnProperty.call(json, "role") && (this.role = json.role);
            _hasOwnProperty.call(json, "uid") && (this.uid = json.uid);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new AuthConf();
        }
        static create(is) {
            return tars.AuthConf._readFrom(is);
        }
    }
    AuthConf._classname = "tars.AuthConf";
    tars.AuthConf = AuthConf;
    class AuthConfList {
        constructor() {
            this.auths = new TarsStream.List(tars.AuthConf);
            this._proto_struct_name_ = "";
            this._classname = "tars.AuthConfList";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new AuthConfList;
            tmp.auths = is.readList(0, false, TarsStream.List(tars.AuthConf));
            return tmp;
        }
        _writeTo(os) {
            os.writeList(0, this.auths);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                auths: this.auths.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "auths") && (this.auths.readFromObject(json.auths));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new AuthConfList();
        }
        static create(is) {
            return tars.AuthConfList._readFrom(is);
        }
    }
    AuthConfList._classname = "tars.AuthConfList";
    tars.AuthConfList = AuthConfList;
    class AdminRegProxy {
        setTimeout(iTimeout) { this._worker.timeout = iTimeout; }
        getTimeout() { return this._worker.timeout; }
        setVersion(iVersion) { this._worker.version = iVersion; }
        getVersion() { return this._worker.version; }
        checkTicket(ticket, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("checkTicket", AdminRegProxy.checkTicket.tupEncoder(ticket, version), tars_options, AdminRegProxy.checkTicket).then(AdminRegProxy.checkTicket.tupDecoder, AdminRegProxy.checkTicket.errorResponser);
            }
            else {
                return this._worker.tars_invoke("checkTicket", AdminRegProxy.checkTicket.tarsEncoder(ticket), tars_options, AdminRegProxy.checkTicket).then(AdminRegProxy.checkTicket.tarsDecoder, AdminRegProxy.checkTicket.errorResponser);
            }
        }
        hasAdminAuth(uid, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasAdminAuth", AdminRegProxy.hasAdminAuth.tupEncoder(uid, version), tars_options, AdminRegProxy.hasAdminAuth).then(AdminRegProxy.hasAdminAuth.tupDecoder, AdminRegProxy.hasAdminAuth.errorResponser);
            }
            else {
                return this._worker.tars_invoke("hasAdminAuth", AdminRegProxy.hasAdminAuth.tarsEncoder(uid), tars_options, AdminRegProxy.hasAdminAuth).then(AdminRegProxy.hasAdminAuth.tarsDecoder, AdminRegProxy.hasAdminAuth.errorResponser);
            }
        }
        hasDevAuth(application, serverName, uid, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasDevAuth", AdminRegProxy.hasDevAuth.tupEncoder(application, serverName, uid, version), tars_options, AdminRegProxy.hasDevAuth).then(AdminRegProxy.hasDevAuth.tupDecoder, AdminRegProxy.hasDevAuth.errorResponser);
            }
            else {
                return this._worker.tars_invoke("hasDevAuth", AdminRegProxy.hasDevAuth.tarsEncoder(application, serverName, uid), tars_options, AdminRegProxy.hasDevAuth).then(AdminRegProxy.hasDevAuth.tarsDecoder, AdminRegProxy.hasDevAuth.errorResponser);
            }
        }
        hasOpeAuth(application, serverName, uid, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasOpeAuth", AdminRegProxy.hasOpeAuth.tupEncoder(application, serverName, uid, version), tars_options, AdminRegProxy.hasOpeAuth).then(AdminRegProxy.hasOpeAuth.tupDecoder, AdminRegProxy.hasOpeAuth.errorResponser);
            }
            else {
                return this._worker.tars_invoke("hasOpeAuth", AdminRegProxy.hasOpeAuth.tarsEncoder(application, serverName, uid), tars_options, AdminRegProxy.hasOpeAuth).then(AdminRegProxy.hasOpeAuth.tarsDecoder, AdminRegProxy.hasOpeAuth.errorResponser);
            }
        }
        notifyServer(application, serverName, nodeName, command, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("notifyServer", AdminRegProxy.notifyServer.tupEncoder(application, serverName, nodeName, command, version), tars_options, AdminRegProxy.notifyServer).then(AdminRegProxy.notifyServer.tupDecoder, AdminRegProxy.notifyServer.errorResponser);
            }
            else {
                return this._worker.tars_invoke("notifyServer", AdminRegProxy.notifyServer.tarsEncoder(application, serverName, nodeName, command), tars_options, AdminRegProxy.notifyServer).then(AdminRegProxy.notifyServer.tarsDecoder, AdminRegProxy.notifyServer.errorResponser);
            }
        }
        pingNode(name, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("pingNode", AdminRegProxy.pingNode.tupEncoder(name, version), tars_options, AdminRegProxy.pingNode).then(AdminRegProxy.pingNode.tupDecoder, AdminRegProxy.pingNode.errorResponser);
            }
            else {
                return this._worker.tars_invoke("pingNode", AdminRegProxy.pingNode.tarsEncoder(name), tars_options, AdminRegProxy.pingNode).then(AdminRegProxy.pingNode.tarsDecoder, AdminRegProxy.pingNode.errorResponser);
            }
        }
        registerPlugin(conf, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("registerPlugin", AdminRegProxy.registerPlugin.tupEncoder(conf, version), tars_options, AdminRegProxy.registerPlugin).then(AdminRegProxy.registerPlugin.tupDecoder, AdminRegProxy.registerPlugin.errorResponser);
            }
            else {
                return this._worker.tars_invoke("registerPlugin", AdminRegProxy.registerPlugin.tarsEncoder(conf), tars_options, AdminRegProxy.registerPlugin).then(AdminRegProxy.registerPlugin.tarsDecoder, AdminRegProxy.registerPlugin.errorResponser);
            }
        }
        restartServer(application, serverName, nodeName, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("restartServer", AdminRegProxy.restartServer.tupEncoder(application, serverName, nodeName, version), tars_options, AdminRegProxy.restartServer).then(AdminRegProxy.restartServer.tupDecoder, AdminRegProxy.restartServer.errorResponser);
            }
            else {
                return this._worker.tars_invoke("restartServer", AdminRegProxy.restartServer.tarsEncoder(application, serverName, nodeName), tars_options, AdminRegProxy.restartServer).then(AdminRegProxy.restartServer.tarsDecoder, AdminRegProxy.restartServer.errorResponser);
            }
        }
        startServer(application, serverName, nodeName, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("startServer", AdminRegProxy.startServer.tupEncoder(application, serverName, nodeName, version), tars_options, AdminRegProxy.startServer).then(AdminRegProxy.startServer.tupDecoder, AdminRegProxy.startServer.errorResponser);
            }
            else {
                return this._worker.tars_invoke("startServer", AdminRegProxy.startServer.tarsEncoder(application, serverName, nodeName), tars_options, AdminRegProxy.startServer).then(AdminRegProxy.startServer.tarsDecoder, AdminRegProxy.startServer.errorResponser);
            }
        }
        stopServer(application, serverName, nodeName, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("stopServer", AdminRegProxy.stopServer.tupEncoder(application, serverName, nodeName, version), tars_options, AdminRegProxy.stopServer).then(AdminRegProxy.stopServer.tupDecoder, AdminRegProxy.stopServer.errorResponser);
            }
            else {
                return this._worker.tars_invoke("stopServer", AdminRegProxy.stopServer.tarsEncoder(application, serverName, nodeName), tars_options, AdminRegProxy.stopServer).then(AdminRegProxy.stopServer.tarsDecoder, AdminRegProxy.stopServer.errorResponser);
            }
        }
        tars_ping(tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("tars_ping", AdminRegProxy.tars_ping.tupEncoder(version), tars_options, AdminRegProxy.tars_ping).then(AdminRegProxy.tars_ping.tupDecoder, AdminRegProxy.tars_ping.errorResponser);
            }
            else {
                return this._worker.tars_invoke("tars_ping", AdminRegProxy.tars_ping.tarsEncoder(), tars_options, AdminRegProxy.tars_ping).then(AdminRegProxy.tars_ping.tarsDecoder, AdminRegProxy.tars_ping.errorResponser);
            }
        }
    }
    AdminRegProxy.checkTicket = _castFunctionInfo({
        name: "checkTicket",
        return: "int32",
        arguments: [{
                name: "ticket",
                class: "string",
                direction: "in"
            }, {
                name: "uid",
                class: "string",
                direction: "out"
            }],
        tarsEncoder(ticket) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, ticket);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            uid: is.readString(2, true, "")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(ticket, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("ticket", ticket);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            uid: tup.readString("uid")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::checkTicket failed");
        }
    });
    AdminRegProxy.hasAdminAuth = _castFunctionInfo({
        name: "hasAdminAuth",
        return: "int32",
        arguments: [{
                name: "uid",
                class: "string",
                direction: "in"
            }, {
                name: "has",
                class: "bool",
                direction: "out"
            }],
        tarsEncoder(uid) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, uid);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            has: is.readBoolean(2, true, true)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(uid, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("uid", uid);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            has: tup.readBoolean("has")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::hasAdminAuth failed");
        }
    });
    AdminRegProxy.hasDevAuth = _castFunctionInfo({
        name: "hasDevAuth",
        return: "int32",
        arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "uid",
                class: "string",
                direction: "in"
            }, {
                name: "has",
                class: "bool",
                direction: "out"
            }],
        tarsEncoder(application, serverName, uid) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, application);
            os.writeString(2, serverName);
            os.writeString(3, uid);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            has: is.readBoolean(4, true, true)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(application, serverName, uid, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("application", application);
            tup.writeString("serverName", serverName);
            tup.writeString("uid", uid);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            has: tup.readBoolean("has")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::hasDevAuth failed");
        }
    });
    AdminRegProxy.hasOpeAuth = _castFunctionInfo({
        name: "hasOpeAuth",
        return: "int32",
        arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "uid",
                class: "string",
                direction: "in"
            }, {
                name: "has",
                class: "bool",
                direction: "out"
            }],
        tarsEncoder(application, serverName, uid) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, application);
            os.writeString(2, serverName);
            os.writeString(3, uid);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            has: is.readBoolean(4, true, true)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(application, serverName, uid, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("application", application);
            tup.writeString("serverName", serverName);
            tup.writeString("uid", uid);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            has: tup.readBoolean("has")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::hasOpeAuth failed");
        }
    });
    AdminRegProxy.notifyServer = _castFunctionInfo({
        name: "notifyServer",
        return: "int32",
        arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "command",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
        tarsEncoder(application, serverName, nodeName, command) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, application);
            os.writeString(2, serverName);
            os.writeString(3, nodeName);
            os.writeString(4, command);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            result: is.readString(5, true, "")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(application, serverName, nodeName, command, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("application", application);
            tup.writeString("serverName", serverName);
            tup.writeString("nodeName", nodeName);
            tup.writeString("command", command);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            result: tup.readString("result")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::notifyServer failed");
        }
    });
    AdminRegProxy.pingNode = _castFunctionInfo({
        name: "pingNode",
        return: "bool",
        arguments: [{
                name: "name",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
        tarsEncoder(name) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, name);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readBoolean(0, true, true),
                        arguments: {
                            result: is.readString(2, true, "")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(name, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("name", name);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readBoolean("", false),
                        arguments: {
                            result: tup.readString("result")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::pingNode failed");
        }
    });
    AdminRegProxy.registerPlugin = _castFunctionInfo({
        name: "registerPlugin",
        return: "int32",
        arguments: [{
                name: "conf",
                class: "tars.PluginConf",
                direction: "in"
            }],
        tarsEncoder(conf) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, conf);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(conf, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("conf", conf);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::registerPlugin failed");
        }
    });
    AdminRegProxy.restartServer = _castFunctionInfo({
        name: "restartServer",
        return: "int32",
        arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
        tarsEncoder(application, serverName, nodeName) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, application);
            os.writeString(2, serverName);
            os.writeString(3, nodeName);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            result: is.readString(4, true, "")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(application, serverName, nodeName, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("application", application);
            tup.writeString("serverName", serverName);
            tup.writeString("nodeName", nodeName);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            result: tup.readString("result")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::restartServer failed");
        }
    });
    AdminRegProxy.startServer = _castFunctionInfo({
        name: "startServer",
        return: "int32",
        arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
        tarsEncoder(application, serverName, nodeName) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, application);
            os.writeString(2, serverName);
            os.writeString(3, nodeName);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            result: is.readString(4, true, "")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(application, serverName, nodeName, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("application", application);
            tup.writeString("serverName", serverName);
            tup.writeString("nodeName", nodeName);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            result: tup.readString("result")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::startServer failed");
        }
    });
    AdminRegProxy.stopServer = _castFunctionInfo({
        name: "stopServer",
        return: "int32",
        arguments: [{
                name: "application",
                class: "string",
                direction: "in"
            }, {
                name: "serverName",
                class: "string",
                direction: "in"
            }, {
                name: "nodeName",
                class: "string",
                direction: "in"
            }, {
                name: "result",
                class: "string",
                direction: "out"
            }],
        tarsEncoder(application, serverName, nodeName) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, application);
            os.writeString(2, serverName);
            os.writeString(3, nodeName);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            result: is.readString(4, true, "")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(application, serverName, nodeName, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("application", application);
            tup.writeString("serverName", serverName);
            tup.writeString("nodeName", nodeName);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            result: tup.readString("result")
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::stopServer failed");
        }
    });
    AdminRegProxy.tars_ping = _castFunctionInfo({
        name: "tars_ping",
        return: "void",
        arguments: [],
        tarsEncoder() {
            const os = new TarsStream.TarsOutputStream();
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: undefined,
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(__$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            return tup;
        },
        tupDecoder(data) {
            try {
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: undefined,
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call AdminReg::tars_ping failed");
        }
    });
    tars.AdminRegProxy = AdminRegProxy;
})(tars = exports.tars || (exports.tars = {}));
