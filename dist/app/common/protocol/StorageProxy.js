"use strict";
// **********************************************************************
// Parsed By TarsParser(3.0.12), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "Storage.tars" by Client Mode
// **********************************************************************
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base = void 0;
/* tslint:disable */
/* eslint-disable */
/// <reference types="node" />
const assert = require("assert");
const TarsStream = __importStar(require("@tars/stream"));
const TarsRpc = __importStar(require("@tars/rpc"));
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo(data) { return data; }
function _makeError(data, message, type) {
    var error = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    }
    else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}
var Base;
(function (Base) {
    let STORAGE_RT;
    (function (STORAGE_RT) {
        STORAGE_RT[STORAGE_RT["S_OK"] = 0] = "S_OK";
        STORAGE_RT[STORAGE_RT["S_NO_DATA"] = -1] = "S_NO_DATA";
        STORAGE_RT[STORAGE_RT["S_ERROR"] = -2] = "S_ERROR";
        STORAGE_RT[STORAGE_RT["S_VERSION"] = -3] = "S_VERSION";
        STORAGE_RT[STORAGE_RT["S_TIMESTAMP"] = -4] = "S_TIMESTAMP";
        STORAGE_RT[STORAGE_RT["S_TABLE_NAME"] = -5] = "S_TABLE_NAME";
        STORAGE_RT[STORAGE_RT["S_TABLE_EXIST"] = -6] = "S_TABLE_EXIST";
        STORAGE_RT[STORAGE_RT["S_TABLE_NOT_EXIST"] = -7] = "S_TABLE_NOT_EXIST";
        STORAGE_RT[STORAGE_RT["S_JSON_FIELD_NOT_EXITS"] = -8] = "S_JSON_FIELD_NOT_EXITS";
        STORAGE_RT[STORAGE_RT["S_JSON_OPERATOR_NOT_SUPPORT"] = -9] = "S_JSON_OPERATOR_NOT_SUPPORT";
        STORAGE_RT[STORAGE_RT["S_JSON_FIELD_TYPE_ERROR"] = -10] = "S_JSON_FIELD_TYPE_ERROR";
        STORAGE_RT[STORAGE_RT["S_JSON_VALUE_TYPE_ERROR"] = -11] = "S_JSON_VALUE_TYPE_ERROR";
        STORAGE_RT[STORAGE_RT["S_JSON_VALUE_NOT_JSON"] = -12] = "S_JSON_VALUE_NOT_JSON";
        STORAGE_RT[STORAGE_RT["S_QUEUE_NAME"] = -13] = "S_QUEUE_NAME";
        STORAGE_RT[STORAGE_RT["S_QUEUE_EXIST"] = -14] = "S_QUEUE_EXIST";
        STORAGE_RT[STORAGE_RT["S_QUEUE_NOT_EXIST"] = -15] = "S_QUEUE_NOT_EXIST";
    })(STORAGE_RT = Base.STORAGE_RT || (Base.STORAGE_RT = {}));
    (function (STORAGE_RT) {
        STORAGE_RT._classname = "Base.STORAGE_RT";
        function _write(os, tag, val) { return os.writeInt32(tag, val); }
        STORAGE_RT._write = _write;
        function _read(is, tag, def) { return is.readInt32(tag, true, def); }
        STORAGE_RT._read = _read;
    })(STORAGE_RT = Base.STORAGE_RT || (Base.STORAGE_RT = {}));
    let StorageOperator;
    (function (StorageOperator) {
        StorageOperator[StorageOperator["SO_REPLACE"] = 0] = "SO_REPLACE";
        StorageOperator[StorageOperator["SO_ADD"] = 1] = "SO_ADD";
        StorageOperator[StorageOperator["SO_SUB"] = 2] = "SO_SUB";
        StorageOperator[StorageOperator["SO_REVERSE"] = 3] = "SO_REVERSE";
        StorageOperator[StorageOperator["SO_ADD_NO_REPEAT"] = 4] = "SO_ADD_NO_REPEAT";
    })(StorageOperator = Base.StorageOperator || (Base.StorageOperator = {}));
    (function (StorageOperator) {
        StorageOperator._classname = "Base.StorageOperator";
        function _write(os, tag, val) { return os.writeInt32(tag, val); }
        StorageOperator._write = _write;
        function _read(is, tag, def) { return is.readInt32(tag, true, def); }
        StorageOperator._read = _read;
    })(StorageOperator = Base.StorageOperator || (Base.StorageOperator = {}));
    let FieldType;
    (function (FieldType) {
        FieldType[FieldType["FT_INTEGER"] = 1] = "FT_INTEGER";
        FieldType[FieldType["FT_DOUBLE"] = 2] = "FT_DOUBLE";
        FieldType[FieldType["FT_BOOLEAN"] = 3] = "FT_BOOLEAN";
        FieldType[FieldType["FT_STRING"] = 4] = "FT_STRING";
        FieldType[FieldType["FT_ARRAY"] = 5] = "FT_ARRAY";
    })(FieldType = Base.FieldType || (Base.FieldType = {}));
    (function (FieldType) {
        FieldType._classname = "Base.FieldType";
        function _write(os, tag, val) { return os.writeInt32(tag, val); }
        FieldType._write = _write;
        function _read(is, tag, def) { return is.readInt32(tag, true, def); }
        FieldType._read = _read;
    })(FieldType = Base.FieldType || (Base.FieldType = {}));
    class Options {
        constructor() {
            this.leader = false;
            this._proto_struct_name_ = "";
            this._classname = "Base.Options";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new Options;
            tmp.leader = is.readBoolean(0, false, false);
            return tmp;
        }
        _writeTo(os) {
            os.writeBoolean(0, this.leader);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                leader: this.leader
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "leader") && (this.leader = json.leader);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new Options();
        }
        static create(is) {
            return Base.Options._readFrom(is);
        }
    }
    Options._classname = "Base.Options";
    Base.Options = Options;
    class StorageKey {
        constructor() {
            this.table = "";
            this.mkey = "";
            this.ukey = "";
            this._proto_struct_name_ = "";
            this._classname = "Base.StorageKey";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new StorageKey;
            tmp.table = is.readString(0, false, "");
            tmp.mkey = is.readString(1, false, "");
            tmp.ukey = is.readString(2, false, "");
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.table);
            os.writeString(1, this.mkey);
            os.writeString(2, this.ukey);
        }
        _equal(anItem) {
            return this.table === anItem.table &&
                this.mkey === anItem.mkey &&
                this.ukey === anItem.ukey;
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                table: this.table,
                mkey: this.mkey,
                ukey: this.ukey
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "table") && (this.table = json.table);
            _hasOwnProperty.call(json, "mkey") && (this.mkey = json.mkey);
            _hasOwnProperty.call(json, "ukey") && (this.ukey = json.ukey);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new StorageKey();
        }
        static create(is) {
            return Base.StorageKey._readFrom(is);
        }
    }
    StorageKey._classname = "Base.StorageKey";
    Base.StorageKey = StorageKey;
    class StorageValue {
        constructor() {
            this.expireTime = 0;
            this.version = 0;
            this.timestamp = 0;
            this.data = new TarsStream.BinBuffer;
            this._proto_struct_name_ = "";
            this._classname = "Base.StorageValue";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new StorageValue;
            tmp.expireTime = is.readInt64(0, false, 0);
            tmp.version = is.readInt32(1, false, 0);
            tmp.timestamp = is.readInt64(2, false, 0);
            tmp.data = is.readBytes(3, false, TarsStream.BinBuffer);
            return tmp;
        }
        _writeTo(os) {
            os.writeInt64(0, this.expireTime);
            os.writeInt32(1, this.version);
            os.writeInt64(2, this.timestamp);
            os.writeBytes(3, this.data);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                expireTime: this.expireTime,
                version: this.version,
                timestamp: this.timestamp,
                data: this.data.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime);
            _hasOwnProperty.call(json, "version") && (this.version = json.version);
            _hasOwnProperty.call(json, "timestamp") && (this.timestamp = json.timestamp);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new StorageValue();
        }
        static create(is) {
            return Base.StorageValue._readFrom(is);
        }
    }
    StorageValue._classname = "Base.StorageValue";
    Base.StorageValue = StorageValue;
    class StorageData {
        constructor() {
            this.skey = new Base.StorageKey;
            this.svalue = new Base.StorageValue;
            this.ret = 0;
            this._proto_struct_name_ = "";
            this._classname = "Base.StorageData";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new StorageData;
            tmp.skey = is.readStruct(0, false, Base.StorageKey);
            tmp.svalue = is.readStruct(1, false, Base.StorageValue);
            tmp.ret = is.readInt32(2, false, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeStruct(0, this.skey);
            os.writeStruct(1, this.svalue);
            os.writeInt32(2, this.ret);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                skey: this.skey.toObject(),
                svalue: this.svalue.toObject(),
                ret: this.ret
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "skey") && (this.skey.readFromObject(json.skey));
            _hasOwnProperty.call(json, "svalue") && (this.svalue.readFromObject(json.svalue));
            _hasOwnProperty.call(json, "ret") && (this.ret = json.ret);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new StorageData();
        }
        static create(is) {
            return Base.StorageData._readFrom(is);
        }
    }
    StorageData._classname = "Base.StorageData";
    Base.StorageData = StorageData;
    class StorageUpdate {
        constructor() {
            this.field = "";
            this.op = Base.StorageOperator.SO_REPLACE;
            this.value = "";
            this.type = Base.FieldType.FT_INTEGER;
            this.def = "";
            this._proto_struct_name_ = "";
            this._classname = "Base.StorageUpdate";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new StorageUpdate;
            tmp.field = is.readString(0, true, "");
            tmp.op = is.readInt32(1, true, Base.StorageOperator.SO_REPLACE);
            tmp.value = is.readString(2, false, "");
            tmp.type = is.readInt32(3, false, Base.FieldType.FT_INTEGER);
            tmp.def = is.readString(4, false, "");
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.field);
            os.writeInt32(1, this.op);
            os.writeString(2, this.value);
            os.writeInt32(3, this.type);
            os.writeString(4, this.def);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                field: this.field,
                op: this.op,
                value: this.value,
                type: this.type,
                def: this.def
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "field") && (this.field = json.field);
            _hasOwnProperty.call(json, "op") && (this.op = json.op);
            _hasOwnProperty.call(json, "value") && (this.value = json.value);
            _hasOwnProperty.call(json, "type") && (this.type = json.type);
            _hasOwnProperty.call(json, "def") && (this.def = json.def);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new StorageUpdate();
        }
        static create(is) {
            return Base.StorageUpdate._readFrom(is);
        }
    }
    StorageUpdate._classname = "Base.StorageUpdate";
    Base.StorageUpdate = StorageUpdate;
    class StorageJson {
        constructor() {
            this.skey = new Base.StorageKey;
            this.supdate = new TarsStream.List(Base.StorageUpdate);
            this._proto_struct_name_ = "";
            this._classname = "Base.StorageJson";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new StorageJson;
            tmp.skey = is.readStruct(0, false, Base.StorageKey);
            tmp.supdate = is.readList(1, false, TarsStream.List(Base.StorageUpdate));
            return tmp;
        }
        _writeTo(os) {
            os.writeStruct(0, this.skey);
            os.writeList(1, this.supdate);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                skey: this.skey.toObject(),
                supdate: this.supdate.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "skey") && (this.skey.readFromObject(json.skey));
            _hasOwnProperty.call(json, "supdate") && (this.supdate.readFromObject(json.supdate));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new StorageJson();
        }
        static create(is) {
            return Base.StorageJson._readFrom(is);
        }
    }
    StorageJson._classname = "Base.StorageJson";
    Base.StorageJson = StorageJson;
    class PageReq {
        constructor() {
            this.skey = new Base.StorageKey;
            this.limit = 10;
            this.forward = true;
            this.include = true;
            this.over = false;
            this._proto_struct_name_ = "";
            this._classname = "Base.PageReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new PageReq;
            tmp.skey = is.readStruct(0, false, Base.StorageKey);
            tmp.limit = is.readInt32(1, false, 10);
            tmp.forward = is.readBoolean(2, false, true);
            tmp.include = is.readBoolean(3, false, true);
            tmp.over = is.readBoolean(4, false, false);
            return tmp;
        }
        _writeTo(os) {
            os.writeStruct(0, this.skey);
            os.writeInt32(1, this.limit);
            os.writeBoolean(2, this.forward);
            os.writeBoolean(3, this.include);
            os.writeBoolean(4, this.over);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                skey: this.skey.toObject(),
                limit: this.limit,
                forward: this.forward,
                include: this.include,
                over: this.over
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "skey") && (this.skey.readFromObject(json.skey));
            _hasOwnProperty.call(json, "limit") && (this.limit = json.limit);
            _hasOwnProperty.call(json, "forward") && (this.forward = json.forward);
            _hasOwnProperty.call(json, "include") && (this.include = json.include);
            _hasOwnProperty.call(json, "over") && (this.over = json.over);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new PageReq();
        }
        static create(is) {
            return Base.PageReq._readFrom(is);
        }
    }
    PageReq._classname = "Base.PageReq";
    Base.PageReq = PageReq;
    class QueueData {
        constructor() {
            this.expireTime = 0;
            this.data = new TarsStream.BinBuffer;
            this._proto_struct_name_ = "";
            this._classname = "Base.QueueData";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueueData;
            tmp.expireTime = is.readInt64(0, false, 0);
            tmp.data = is.readBytes(5, false, TarsStream.BinBuffer);
            return tmp;
        }
        _writeTo(os) {
            os.writeInt64(0, this.expireTime);
            os.writeBytes(5, this.data);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                expireTime: this.expireTime,
                data: this.data.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueueData();
        }
        static create(is) {
            return Base.QueueData._readFrom(is);
        }
    }
    QueueData._classname = "Base.QueueData";
    Base.QueueData = QueueData;
    class QueuePushReq {
        constructor() {
            this.queue = "";
            this.back = true;
            this.expireTime = 0;
            this.data = new TarsStream.BinBuffer;
            this._proto_struct_name_ = "";
            this._classname = "Base.QueuePushReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueuePushReq;
            tmp.queue = is.readString(0, false, "");
            tmp.back = is.readBoolean(1, false, true);
            tmp.expireTime = is.readInt64(2, false, 0);
            tmp.data = is.readBytes(5, false, TarsStream.BinBuffer);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.queue);
            os.writeBoolean(1, this.back);
            os.writeInt64(2, this.expireTime);
            os.writeBytes(5, this.data);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                queue: this.queue,
                back: this.back,
                expireTime: this.expireTime,
                data: this.data.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue);
            _hasOwnProperty.call(json, "back") && (this.back = json.back);
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueuePushReq();
        }
        static create(is) {
            return Base.QueuePushReq._readFrom(is);
        }
    }
    QueuePushReq._classname = "Base.QueuePushReq";
    Base.QueuePushReq = QueuePushReq;
    class QueuePopReq {
        constructor() {
            this.queue = "";
            this.back = true;
            this.count = 1;
            this._proto_struct_name_ = "";
            this._classname = "Base.QueuePopReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueuePopReq;
            tmp.queue = is.readString(0, false, "");
            tmp.back = is.readBoolean(1, false, true);
            tmp.count = is.readInt32(2, false, 1);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.queue);
            os.writeBoolean(1, this.back);
            os.writeInt32(2, this.count);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                queue: this.queue,
                back: this.back,
                count: this.count
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue);
            _hasOwnProperty.call(json, "back") && (this.back = json.back);
            _hasOwnProperty.call(json, "count") && (this.count = json.count);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueuePopReq();
        }
        static create(is) {
            return Base.QueuePopReq._readFrom(is);
        }
    }
    QueuePopReq._classname = "Base.QueuePopReq";
    Base.QueuePopReq = QueuePopReq;
    class QueueRsp {
        constructor() {
            this.queue = "";
            this.index = 0;
            this.expireTime = 0;
            this.data = new TarsStream.BinBuffer;
            this._proto_struct_name_ = "";
            this._classname = "Base.QueueRsp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueueRsp;
            tmp.queue = is.readString(0, false, "");
            tmp.index = is.readInt64(1, false, 0);
            tmp.expireTime = is.readInt64(2, false, 0);
            tmp.data = is.readBytes(3, false, TarsStream.BinBuffer);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.queue);
            os.writeInt64(1, this.index);
            os.writeInt64(2, this.expireTime);
            os.writeBytes(3, this.data);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                queue: this.queue,
                index: this.index,
                expireTime: this.expireTime,
                data: this.data.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue);
            _hasOwnProperty.call(json, "index") && (this.index = json.index);
            _hasOwnProperty.call(json, "expireTime") && (this.expireTime = json.expireTime);
            _hasOwnProperty.call(json, "data") && (this.data.readFromObject(json.data));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueueRsp();
        }
        static create(is) {
            return Base.QueueRsp._readFrom(is);
        }
    }
    QueueRsp._classname = "Base.QueueRsp";
    Base.QueueRsp = QueueRsp;
    class QueueIndex {
        constructor() {
            this.queue = "";
            this.index = 0;
            this._proto_struct_name_ = "";
            this._classname = "Base.QueueIndex";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueueIndex;
            tmp.queue = is.readString(0, false, "");
            tmp.index = is.readInt64(1, false, 0);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.queue);
            os.writeInt64(1, this.index);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                queue: this.queue,
                index: this.index
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue);
            _hasOwnProperty.call(json, "index") && (this.index = json.index);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueueIndex();
        }
        static create(is) {
            return Base.QueueIndex._readFrom(is);
        }
    }
    QueueIndex._classname = "Base.QueueIndex";
    Base.QueueIndex = QueueIndex;
    class QueuePageReq {
        constructor() {
            this.queue = "";
            this.index = "";
            this.limit = 10;
            this.forward = true;
            this.include = true;
            this._proto_struct_name_ = "";
            this._classname = "Base.QueuePageReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new QueuePageReq;
            tmp.queue = is.readString(0, false, "");
            tmp.index = is.readString(1, false, "");
            tmp.limit = is.readInt32(2, false, 10);
            tmp.forward = is.readBoolean(3, false, true);
            tmp.include = is.readBoolean(4, false, true);
            return tmp;
        }
        _writeTo(os) {
            os.writeString(0, this.queue);
            os.writeString(1, this.index);
            os.writeInt32(2, this.limit);
            os.writeBoolean(3, this.forward);
            os.writeBoolean(4, this.include);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                queue: this.queue,
                index: this.index,
                limit: this.limit,
                forward: this.forward,
                include: this.include
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "queue") && (this.queue = json.queue);
            _hasOwnProperty.call(json, "index") && (this.index = json.index);
            _hasOwnProperty.call(json, "limit") && (this.limit = json.limit);
            _hasOwnProperty.call(json, "forward") && (this.forward = json.forward);
            _hasOwnProperty.call(json, "include") && (this.include = json.include);
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new QueuePageReq();
        }
        static create(is) {
            return Base.QueuePageReq._readFrom(is);
        }
    }
    QueuePageReq._classname = "Base.QueuePageReq";
    Base.QueuePageReq = QueuePageReq;
    class BatchDataReq {
        constructor() {
            this.sData = new TarsStream.List(Base.StorageData);
            this.uData = new TarsStream.List(Base.StorageJson);
            this.qData = new TarsStream.List(Base.QueuePushReq);
            this._proto_struct_name_ = "";
            this._classname = "Base.BatchDataReq";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new BatchDataReq;
            tmp.sData = is.readList(0, false, TarsStream.List(Base.StorageData));
            tmp.uData = is.readList(1, false, TarsStream.List(Base.StorageJson));
            tmp.qData = is.readList(2, false, TarsStream.List(Base.QueuePushReq));
            return tmp;
        }
        _writeTo(os) {
            os.writeList(0, this.sData);
            os.writeList(1, this.uData);
            os.writeList(2, this.qData);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                sData: this.sData.toObject(),
                uData: this.uData.toObject(),
                qData: this.qData.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "sData") && (this.sData.readFromObject(json.sData));
            _hasOwnProperty.call(json, "uData") && (this.uData.readFromObject(json.uData));
            _hasOwnProperty.call(json, "qData") && (this.qData.readFromObject(json.qData));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new BatchDataReq();
        }
        static create(is) {
            return Base.BatchDataReq._readFrom(is);
        }
    }
    BatchDataReq._classname = "Base.BatchDataReq";
    Base.BatchDataReq = BatchDataReq;
    class BatchDataRsp {
        constructor() {
            this.sRsp = new TarsStream.Map(Base.StorageKey, TarsStream.Int32);
            this._proto_struct_name_ = "";
            this._classname = "Base.BatchDataRsp";
        }
        static _write(os, tag, val) { os.writeStruct(tag, val); }
        static _read(is, tag, def) { return is.readStruct(tag, true, def); }
        static _readFrom(is) {
            const tmp = new BatchDataRsp;
            tmp.sRsp = is.readMap(0, false, TarsStream.Map(Base.StorageKey, TarsStream.Int32));
            return tmp;
        }
        _writeTo(os) {
            os.writeMap(0, this.sRsp);
        }
        _equal() {
            assert.fail("this structure not define key operation");
        }
        _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }
        toObject() {
            return {
                sRsp: this.sRsp.toObject()
            };
        }
        readFromObject(json) {
            _hasOwnProperty.call(json, "sRsp") && (this.sRsp.readFromObject(json.sRsp));
            return this;
        }
        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }
        static new() {
            return new BatchDataRsp();
        }
        static create(is) {
            return Base.BatchDataRsp._readFrom(is);
        }
    }
    BatchDataRsp._classname = "Base.BatchDataRsp";
    Base.BatchDataRsp = BatchDataRsp;
    class StorageProxy {
        setTimeout(iTimeout) { this._worker.timeout = iTimeout; }
        getTimeout() { return this._worker.timeout; }
        setVersion(iVersion) { this._worker.version = iVersion; }
        getVersion() { return this._worker.version; }
        createQueue(queue, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("createQueue", StorageProxy.createQueue.tupEncoder(queue, version), tars_options, StorageProxy.createQueue).then(StorageProxy.createQueue.tupDecoder, StorageProxy.createQueue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("createQueue", StorageProxy.createQueue.tarsEncoder(queue), tars_options, StorageProxy.createQueue).then(StorageProxy.createQueue.tarsDecoder, StorageProxy.createQueue.errorResponser);
            }
        }
        createTable(table, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("createTable", StorageProxy.createTable.tupEncoder(table, version), tars_options, StorageProxy.createTable).then(StorageProxy.createTable.tupDecoder, StorageProxy.createTable.errorResponser);
            }
            else {
                return this._worker.tars_invoke("createTable", StorageProxy.createTable.tarsEncoder(table), tars_options, StorageProxy.createTable).then(StorageProxy.createTable.tarsDecoder, StorageProxy.createTable.errorResponser);
            }
        }
        del(skey, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("del", StorageProxy.del.tupEncoder(skey, version), tars_options, StorageProxy.del).then(StorageProxy.del.tupDecoder, StorageProxy.del.errorResponser);
            }
            else {
                return this._worker.tars_invoke("del", StorageProxy.del.tarsEncoder(skey), tars_options, StorageProxy.del).then(StorageProxy.del.tarsDecoder, StorageProxy.del.errorResponser);
            }
        }
        delBatch(skey, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("delBatch", StorageProxy.delBatch.tupEncoder(skey, version), tars_options, StorageProxy.delBatch).then(StorageProxy.delBatch.tupDecoder, StorageProxy.delBatch.errorResponser);
            }
            else {
                return this._worker.tars_invoke("delBatch", StorageProxy.delBatch.tarsEncoder(skey), tars_options, StorageProxy.delBatch).then(StorageProxy.delBatch.tarsDecoder, StorageProxy.delBatch.errorResponser);
            }
        }
        deleteQueue(queue, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("deleteQueue", StorageProxy.deleteQueue.tupEncoder(queue, version), tars_options, StorageProxy.deleteQueue).then(StorageProxy.deleteQueue.tupDecoder, StorageProxy.deleteQueue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("deleteQueue", StorageProxy.deleteQueue.tarsEncoder(queue), tars_options, StorageProxy.deleteQueue).then(StorageProxy.deleteQueue.tarsDecoder, StorageProxy.deleteQueue.errorResponser);
            }
        }
        deleteQueueData(req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("deleteQueueData", StorageProxy.deleteQueueData.tupEncoder(req, version), tars_options, StorageProxy.deleteQueueData).then(StorageProxy.deleteQueueData.tupDecoder, StorageProxy.deleteQueueData.errorResponser);
            }
            else {
                return this._worker.tars_invoke("deleteQueueData", StorageProxy.deleteQueueData.tarsEncoder(req), tars_options, StorageProxy.deleteQueueData).then(StorageProxy.deleteQueueData.tarsDecoder, StorageProxy.deleteQueueData.errorResponser);
            }
        }
        deleteTable(table, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("deleteTable", StorageProxy.deleteTable.tupEncoder(table, version), tars_options, StorageProxy.deleteTable).then(StorageProxy.deleteTable.tupDecoder, StorageProxy.deleteTable.errorResponser);
            }
            else {
                return this._worker.tars_invoke("deleteTable", StorageProxy.deleteTable.tarsEncoder(table), tars_options, StorageProxy.deleteTable).then(StorageProxy.deleteTable.tarsDecoder, StorageProxy.deleteTable.errorResponser);
            }
        }
        doBatch(req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("doBatch", StorageProxy.doBatch.tupEncoder(req, version), tars_options, StorageProxy.doBatch).then(StorageProxy.doBatch.tupDecoder, StorageProxy.doBatch.errorResponser);
            }
            else {
                return this._worker.tars_invoke("doBatch", StorageProxy.doBatch.tarsEncoder(req), tars_options, StorageProxy.doBatch).then(StorageProxy.doBatch.tarsDecoder, StorageProxy.doBatch.errorResponser);
            }
        }
        get(opt, skey, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("get", StorageProxy.get.tupEncoder(opt, skey, version), tars_options, StorageProxy.get).then(StorageProxy.get.tupDecoder, StorageProxy.get.errorResponser);
            }
            else {
                return this._worker.tars_invoke("get", StorageProxy.get.tarsEncoder(opt, skey), tars_options, StorageProxy.get).then(StorageProxy.get.tarsDecoder, StorageProxy.get.errorResponser);
            }
        }
        getBatch(opt, skey, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getBatch", StorageProxy.getBatch.tupEncoder(opt, skey, version), tars_options, StorageProxy.getBatch).then(StorageProxy.getBatch.tupDecoder, StorageProxy.getBatch.errorResponser);
            }
            else {
                return this._worker.tars_invoke("getBatch", StorageProxy.getBatch.tarsEncoder(opt, skey), tars_options, StorageProxy.getBatch).then(StorageProxy.getBatch.tarsDecoder, StorageProxy.getBatch.errorResponser);
            }
        }
        getQueueData(opt, req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("getQueueData", StorageProxy.getQueueData.tupEncoder(opt, req, version), tars_options, StorageProxy.getQueueData).then(StorageProxy.getQueueData.tupDecoder, StorageProxy.getQueueData.errorResponser);
            }
            else {
                return this._worker.tars_invoke("getQueueData", StorageProxy.getQueueData.tarsEncoder(opt, req), tars_options, StorageProxy.getQueueData).then(StorageProxy.getQueueData.tarsDecoder, StorageProxy.getQueueData.errorResponser);
            }
        }
        get_queue(opt, req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("get_queue", StorageProxy.get_queue.tupEncoder(opt, req, version), tars_options, StorageProxy.get_queue).then(StorageProxy.get_queue.tupDecoder, StorageProxy.get_queue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("get_queue", StorageProxy.get_queue.tarsEncoder(opt, req), tars_options, StorageProxy.get_queue).then(StorageProxy.get_queue.tarsDecoder, StorageProxy.get_queue.errorResponser);
            }
        }
        has(opt, skey, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("has", StorageProxy.has.tupEncoder(opt, skey, version), tars_options, StorageProxy.has).then(StorageProxy.has.tupDecoder, StorageProxy.has.errorResponser);
            }
            else {
                return this._worker.tars_invoke("has", StorageProxy.has.tarsEncoder(opt, skey), tars_options, StorageProxy.has).then(StorageProxy.has.tarsDecoder, StorageProxy.has.errorResponser);
            }
        }
        hasBatch(opt, data, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("hasBatch", StorageProxy.hasBatch.tupEncoder(opt, data, version), tars_options, StorageProxy.hasBatch).then(StorageProxy.hasBatch.tupDecoder, StorageProxy.hasBatch.errorResponser);
            }
            else {
                return this._worker.tars_invoke("hasBatch", StorageProxy.hasBatch.tarsEncoder(opt, data), tars_options, StorageProxy.hasBatch).then(StorageProxy.hasBatch.tarsDecoder, StorageProxy.hasBatch.errorResponser);
            }
        }
        listQueue(opt, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("listQueue", StorageProxy.listQueue.tupEncoder(opt, version), tars_options, StorageProxy.listQueue).then(StorageProxy.listQueue.tupDecoder, StorageProxy.listQueue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("listQueue", StorageProxy.listQueue.tarsEncoder(opt), tars_options, StorageProxy.listQueue).then(StorageProxy.listQueue.tarsDecoder, StorageProxy.listQueue.errorResponser);
            }
        }
        listTable(opt, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("listTable", StorageProxy.listTable.tupEncoder(opt, version), tars_options, StorageProxy.listTable).then(StorageProxy.listTable.tupDecoder, StorageProxy.listTable.errorResponser);
            }
            else {
                return this._worker.tars_invoke("listTable", StorageProxy.listTable.tarsEncoder(opt), tars_options, StorageProxy.listTable).then(StorageProxy.listTable.tarsDecoder, StorageProxy.listTable.errorResponser);
            }
        }
        pop_queue(req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("pop_queue", StorageProxy.pop_queue.tupEncoder(req, version), tars_options, StorageProxy.pop_queue).then(StorageProxy.pop_queue.tupDecoder, StorageProxy.pop_queue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("pop_queue", StorageProxy.pop_queue.tarsEncoder(req), tars_options, StorageProxy.pop_queue).then(StorageProxy.pop_queue.tarsDecoder, StorageProxy.pop_queue.errorResponser);
            }
        }
        push_queue(req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("push_queue", StorageProxy.push_queue.tupEncoder(req, version), tars_options, StorageProxy.push_queue).then(StorageProxy.push_queue.tupDecoder, StorageProxy.push_queue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("push_queue", StorageProxy.push_queue.tarsEncoder(req), tars_options, StorageProxy.push_queue).then(StorageProxy.push_queue.tarsDecoder, StorageProxy.push_queue.errorResponser);
            }
        }
        set(data, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("set", StorageProxy.set.tupEncoder(data, version), tars_options, StorageProxy.set).then(StorageProxy.set.tupDecoder, StorageProxy.set.errorResponser);
            }
            else {
                return this._worker.tars_invoke("set", StorageProxy.set.tarsEncoder(data), tars_options, StorageProxy.set).then(StorageProxy.set.tarsDecoder, StorageProxy.set.errorResponser);
            }
        }
        setBatch(data, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("setBatch", StorageProxy.setBatch.tupEncoder(data, version), tars_options, StorageProxy.setBatch).then(StorageProxy.setBatch.tupDecoder, StorageProxy.setBatch.errorResponser);
            }
            else {
                return this._worker.tars_invoke("setBatch", StorageProxy.setBatch.tarsEncoder(data), tars_options, StorageProxy.setBatch).then(StorageProxy.setBatch.tarsDecoder, StorageProxy.setBatch.errorResponser);
            }
        }
        setQueueData(data, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("setQueueData", StorageProxy.setQueueData.tupEncoder(data, version), tars_options, StorageProxy.setQueueData).then(StorageProxy.setQueueData.tupDecoder, StorageProxy.setQueueData.errorResponser);
            }
            else {
                return this._worker.tars_invoke("setQueueData", StorageProxy.setQueueData.tarsEncoder(data), tars_options, StorageProxy.setQueueData).then(StorageProxy.setQueueData.tarsDecoder, StorageProxy.setQueueData.errorResponser);
            }
        }
        tars_ping(tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("tars_ping", StorageProxy.tars_ping.tupEncoder(version), tars_options, StorageProxy.tars_ping).then(StorageProxy.tars_ping.tupDecoder, StorageProxy.tars_ping.errorResponser);
            }
            else {
                return this._worker.tars_invoke("tars_ping", StorageProxy.tars_ping.tarsEncoder(), tars_options, StorageProxy.tars_ping).then(StorageProxy.tars_ping.tarsDecoder, StorageProxy.tars_ping.errorResponser);
            }
        }
        trans(opt, req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("trans", StorageProxy.trans.tupEncoder(opt, req, version), tars_options, StorageProxy.trans).then(StorageProxy.trans.tupDecoder, StorageProxy.trans.errorResponser);
            }
            else {
                return this._worker.tars_invoke("trans", StorageProxy.trans.tarsEncoder(opt, req), tars_options, StorageProxy.trans).then(StorageProxy.trans.tarsDecoder, StorageProxy.trans.errorResponser);
            }
        }
        transQueue(opt, req, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("transQueue", StorageProxy.transQueue.tupEncoder(opt, req, version), tars_options, StorageProxy.transQueue).then(StorageProxy.transQueue.tupDecoder, StorageProxy.transQueue.errorResponser);
            }
            else {
                return this._worker.tars_invoke("transQueue", StorageProxy.transQueue.tarsEncoder(opt, req), tars_options, StorageProxy.transQueue).then(StorageProxy.transQueue.tarsDecoder, StorageProxy.transQueue.errorResponser);
            }
        }
        update(data, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("update", StorageProxy.update.tupEncoder(data, version), tars_options, StorageProxy.update).then(StorageProxy.update.tupDecoder, StorageProxy.update.errorResponser);
            }
            else {
                return this._worker.tars_invoke("update", StorageProxy.update.tarsEncoder(data), tars_options, StorageProxy.update).then(StorageProxy.update.tarsDecoder, StorageProxy.update.errorResponser);
            }
        }
        updateBatch(data, tars_options) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("updateBatch", StorageProxy.updateBatch.tupEncoder(data, version), tars_options, StorageProxy.updateBatch).then(StorageProxy.updateBatch.tupDecoder, StorageProxy.updateBatch.errorResponser);
            }
            else {
                return this._worker.tars_invoke("updateBatch", StorageProxy.updateBatch.tarsEncoder(data), tars_options, StorageProxy.updateBatch).then(StorageProxy.updateBatch.tarsDecoder, StorageProxy.updateBatch.errorResponser);
            }
        }
    }
    StorageProxy.createQueue = _castFunctionInfo({
        name: "createQueue",
        return: "int32",
        arguments: [{
                name: "queue",
                class: "string",
                direction: "in"
            }],
        tarsEncoder(queue) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, queue);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(queue, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("queue", queue);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::createQueue failed");
        }
    });
    StorageProxy.createTable = _castFunctionInfo({
        name: "createTable",
        return: "int32",
        arguments: [{
                name: "table",
                class: "string",
                direction: "in"
            }],
        tarsEncoder(table) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, table);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(table, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("table", table);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::createTable failed");
        }
    });
    StorageProxy.del = _castFunctionInfo({
        name: "del",
        return: "int32",
        arguments: [{
                name: "skey",
                class: "Base.StorageKey",
                direction: "in"
            }],
        tarsEncoder(skey) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, skey);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(skey, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("skey", skey);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::del failed");
        }
    });
    StorageProxy.delBatch = _castFunctionInfo({
        name: "delBatch",
        return: "int32",
        arguments: [{
                name: "skey",
                class: "list(Base.StorageKey)",
                direction: "in"
            }],
        tarsEncoder(skey) {
            const os = new TarsStream.TarsOutputStream();
            os.writeList(1, skey);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(skey, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeList("skey", skey);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::delBatch failed");
        }
    });
    StorageProxy.deleteQueue = _castFunctionInfo({
        name: "deleteQueue",
        return: "int32",
        arguments: [{
                name: "queue",
                class: "string",
                direction: "in"
            }],
        tarsEncoder(queue) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, queue);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(queue, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("queue", queue);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::deleteQueue failed");
        }
    });
    StorageProxy.deleteQueueData = _castFunctionInfo({
        name: "deleteQueueData",
        return: "int32",
        arguments: [{
                name: "req",
                class: "list(Base.QueueIndex)",
                direction: "in"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeList(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeList("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::deleteQueueData failed");
        }
    });
    StorageProxy.deleteTable = _castFunctionInfo({
        name: "deleteTable",
        return: "int32",
        arguments: [{
                name: "table",
                class: "string",
                direction: "in"
            }],
        tarsEncoder(table) {
            const os = new TarsStream.TarsOutputStream();
            os.writeString(1, table);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(table, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeString("table", table);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::deleteTable failed");
        }
    });
    StorageProxy.doBatch = _castFunctionInfo({
        name: "doBatch",
        return: "int32",
        arguments: [{
                name: "req",
                class: "Base.BatchDataReq",
                direction: "in"
            }, {
                name: "rsp",
                class: "Base.BatchDataRsp",
                direction: "out"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            rsp: is.readStruct(2, true, Base.BatchDataRsp)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            rsp: tup.readStruct("rsp", Base.BatchDataRsp)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::doBatch failed");
        }
    });
    StorageProxy.get = _castFunctionInfo({
        name: "get",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "skey",
                class: "Base.StorageKey",
                direction: "in"
            }, {
                name: "data",
                class: "Base.StorageValue",
                direction: "out"
            }],
        tarsEncoder(opt, skey) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeStruct(2, skey);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            data: is.readStruct(3, true, Base.StorageValue)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, skey, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeStruct("skey", skey);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            data: tup.readStruct("data", Base.StorageValue)
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::get failed");
        }
    });
    StorageProxy.getBatch = _castFunctionInfo({
        name: "getBatch",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "skey",
                class: "list(Base.StorageKey)",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.StorageData)",
                direction: "out"
            }],
        tarsEncoder(opt, skey) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeList(2, skey);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            data: is.readList(3, true, TarsStream.List(Base.StorageData))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, skey, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeList("skey", skey);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            data: tup.readList("data", TarsStream.List(Base.StorageData))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::getBatch failed");
        }
    });
    StorageProxy.getQueueData = _castFunctionInfo({
        name: "getQueueData",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "list(Base.QueueIndex)",
                direction: "in"
            }, {
                name: "rsp",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
        tarsEncoder(opt, req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeList(2, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            rsp: is.readList(3, true, TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeList("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            rsp: tup.readList("rsp", TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::getQueueData failed");
        }
    });
    StorageProxy.get_queue = _castFunctionInfo({
        name: "get_queue",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "Base.QueuePopReq",
                direction: "in"
            }, {
                name: "rsp",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
        tarsEncoder(opt, req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeStruct(2, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            rsp: is.readList(3, true, TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            rsp: tup.readList("rsp", TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::get_queue failed");
        }
    });
    StorageProxy.has = _castFunctionInfo({
        name: "has",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "skey",
                class: "Base.StorageKey",
                direction: "in"
            }],
        tarsEncoder(opt, skey) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeStruct(2, skey);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, skey, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeStruct("skey", skey);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::has failed");
        }
    });
    StorageProxy.hasBatch = _castFunctionInfo({
        name: "hasBatch",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.StorageKey)",
                direction: "in"
            }, {
                name: "rsp",
                class: "map(Base.StorageKey, int32)",
                direction: "out"
            }],
        tarsEncoder(opt, data) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeList(2, data);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            rsp: is.readMap(3, true, TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, data, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeList("data", data);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            rsp: tup.readMap("rsp", TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::hasBatch failed");
        }
    });
    StorageProxy.listQueue = _castFunctionInfo({
        name: "listQueue",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "queues",
                class: "list(string)",
                direction: "out"
            }],
        tarsEncoder(opt) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            queues: is.readList(2, true, TarsStream.List(TarsStream.String))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            queues: tup.readList("queues", TarsStream.List(TarsStream.String))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::listQueue failed");
        }
    });
    StorageProxy.listTable = _castFunctionInfo({
        name: "listTable",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "tables",
                class: "list(string)",
                direction: "out"
            }],
        tarsEncoder(opt) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            tables: is.readList(2, true, TarsStream.List(TarsStream.String))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            tables: tup.readList("tables", TarsStream.List(TarsStream.String))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::listTable failed");
        }
    });
    StorageProxy.pop_queue = _castFunctionInfo({
        name: "pop_queue",
        return: "int32",
        arguments: [{
                name: "req",
                class: "Base.QueuePopReq",
                direction: "in"
            }, {
                name: "rsp",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            rsp: is.readList(2, true, TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            rsp: tup.readList("rsp", TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::pop_queue failed");
        }
    });
    StorageProxy.push_queue = _castFunctionInfo({
        name: "push_queue",
        return: "int32",
        arguments: [{
                name: "req",
                class: "list(Base.QueuePushReq)",
                direction: "in"
            }],
        tarsEncoder(req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeList(1, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeList("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::push_queue failed");
        }
    });
    StorageProxy.set = _castFunctionInfo({
        name: "set",
        return: "int32",
        arguments: [{
                name: "data",
                class: "Base.StorageData",
                direction: "in"
            }],
        tarsEncoder(data) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, data);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(data, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("data", data);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::set failed");
        }
    });
    StorageProxy.setBatch = _castFunctionInfo({
        name: "setBatch",
        return: "int32",
        arguments: [{
                name: "data",
                class: "list(Base.StorageData)",
                direction: "in"
            }, {
                name: "rsp",
                class: "map(Base.StorageKey, int32)",
                direction: "out"
            }],
        tarsEncoder(data) {
            const os = new TarsStream.TarsOutputStream();
            os.writeList(1, data);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            rsp: is.readMap(2, true, TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(data, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeList("data", data);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            rsp: tup.readMap("rsp", TarsStream.Map(Base.StorageKey, TarsStream.Int32))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::setBatch failed");
        }
    });
    StorageProxy.setQueueData = _castFunctionInfo({
        name: "setQueueData",
        return: "int32",
        arguments: [{
                name: "data",
                class: "list(Base.QueueRsp)",
                direction: "in"
            }],
        tarsEncoder(data) {
            const os = new TarsStream.TarsOutputStream();
            os.writeList(1, data);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(data, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeList("data", data);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::setQueueData failed");
        }
    });
    StorageProxy.tars_ping = _castFunctionInfo({
        name: "tars_ping",
        return: "void",
        arguments: [],
        tarsEncoder() {
            const os = new TarsStream.TarsOutputStream();
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: undefined,
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(__$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            return tup;
        },
        tupDecoder(data) {
            try {
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: undefined,
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::tars_ping failed");
        }
    });
    StorageProxy.trans = _castFunctionInfo({
        name: "trans",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "Base.PageReq",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.StorageData)",
                direction: "out"
            }],
        tarsEncoder(opt, req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeStruct(2, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            data: is.readList(3, true, TarsStream.List(Base.StorageData))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            data: tup.readList("data", TarsStream.List(Base.StorageData))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::trans failed");
        }
    });
    StorageProxy.transQueue = _castFunctionInfo({
        name: "transQueue",
        return: "int32",
        arguments: [{
                name: "opt",
                class: "Base.Options",
                direction: "in"
            }, {
                name: "req",
                class: "Base.QueuePageReq",
                direction: "in"
            }, {
                name: "data",
                class: "list(Base.QueueRsp)",
                direction: "out"
            }],
        tarsEncoder(opt, req) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, opt);
            os.writeStruct(2, req);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: {
                            data: is.readList(3, true, TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(opt, req, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("opt", opt);
            tup.writeStruct("req", req);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: {
                            data: tup.readList("data", TarsStream.List(Base.QueueRsp))
                        }
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::transQueue failed");
        }
    });
    StorageProxy.update = _castFunctionInfo({
        name: "update",
        return: "int32",
        arguments: [{
                name: "data",
                class: "Base.StorageJson",
                direction: "in"
            }],
        tarsEncoder(data) {
            const os = new TarsStream.TarsOutputStream();
            os.writeStruct(1, data);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(data, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeStruct("data", data);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::update failed");
        }
    });
    StorageProxy.updateBatch = _castFunctionInfo({
        name: "updateBatch",
        return: "int32",
        arguments: [{
                name: "data",
                class: "list(Base.StorageJson)",
                direction: "in"
            }],
        tarsEncoder(data) {
            const os = new TarsStream.TarsOutputStream();
            os.writeList(1, data);
            return os.getBinBuffer();
        },
        tarsDecoder(data) {
            try {
                var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: is.readInt32(0, true, 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        tupEncoder(data, __$PROTOCOL$VERSION) {
            const tup = new TarsStream.UniAttribute();
            tup.tupVersion = __$PROTOCOL$VERSION;
            tup.writeList("data", data);
            return tup;
        },
        tupDecoder(data) {
            try {
                const tup = data.response.tup;
                return {
                    request: data.request,
                    response: {
                        costtime: data.request.costtime,
                        return: tup.readInt32("", 0),
                        arguments: undefined
                    }
                };
            }
            catch (e) {
                throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
            }
        },
        errorResponser(data) {
            throw _makeError(data, "Call Storage::updateBatch failed");
        }
    });
    Base.StorageProxy = StorageProxy;
})(Base = exports.Base || (exports.Base = {}));
